<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iDevOrz</title>
  
  <subtitle>Eat,Code,Sleep</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.devorz.com/"/>
  <updated>2019-05-09T15:20:42.151Z</updated>
  <id>https://www.devorz.com/</id>
  
  <author>
    <name>iDevOrz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在 tableHeaderView 中使用 AutoLayout</title>
    <link href="https://www.devorz.com/2019/05/09/Using-autolayout-in-a-tableHeaderView/"/>
    <id>https://www.devorz.com/2019/05/09/Using-autolayout-in-a-tableHeaderView/</id>
    <published>2019-05-09T14:07:45.000Z</published>
    <updated>2019-05-09T15:20:42.151Z</updated>
    
    <content type="html"><![CDATA[<p>我一直在寻找如何在 <code>tableHeaderView</code> 使用AutoLayout。设置  <code>tableView</code> 的 <code>tableHeaderView</code> 感觉就像在黑洞中投掷视图一样。我们不知道它与层次结构中的其他视图有何关联。</p><p>最后，我找到了一个适合我的解决方案，没有显式的 frame 计算。</p><blockquote><p> 我使用 <code>UIViewController</code> 和 <code>UITableView</code> 作为子视图，而不是<code>UITableViewController</code>。</p></blockquote><p>要点:</p><ol><li>设置 <code>table header view</code></li><li>将 <code>header view</code> 的 <code>centerX</code>，<code>width</code> 和<code>top</code> 锚点固定到 <code>table view</code>.</li><li>用 <code>tableHeaderView</code> 调用 <code>layoutIfNeeded</code> 更新他的大小。</li><li><strong>重新赋值 <code>tableHeaderView</code> </strong></li></ol><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...In viewDidLoad()</span></span><br><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="keyword">let</span> containerView = <span class="type">UIView</span>()</span><br><span class="line">containerView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line"><span class="comment">// headerView is your actual content.</span></span><br><span class="line">containerView.addSubview(headerView)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">self</span>.tableView.tableHeaderView = containerView</span><br><span class="line"><span class="comment">// 3.</span></span><br><span class="line">containerView.centerXAnchor.constraint(equalTo: <span class="keyword">self</span>.tableView.centerXAnchor).isActive = <span class="literal">true</span></span><br><span class="line">containerView.widthAnchor.constraint(equalTo: <span class="keyword">self</span>.tableView.widthAnchor).isActive = <span class="literal">true</span></span><br><span class="line">containerView.topAnchor.constraint(equalTo: <span class="keyword">self</span>.tableView.topAnchor).isActive = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 4.</span></span><br><span class="line"><span class="keyword">self</span>.tableView.tableHeaderView?.layoutIfNeeded()</span><br><span class="line"><span class="keyword">self</span>.tableView.tableHeaderView = <span class="keyword">self</span>.tableView.tableHeaderView</span><br></pre></td></tr></table></figure><h2 id="To-update-the-header-frame-on-device-rotation"><a href="#To-update-the-header-frame-on-device-rotation" class="headerlink" title="To update the header frame on device rotation"></a>To update the header frame on device rotation</h2><p>处理设备旋转需要重新布局的情况：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillTransition</span><span class="params">(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator)</span></span> &#123;</span><br><span class="line">  <span class="keyword">super</span>.viewWillTransition(to: size, with: coordinator)</span><br><span class="line">  <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">    <span class="keyword">self</span>.tableView.tableHeaderView?.layoutIfNeeded()</span><br><span class="line">    <span class="keyword">self</span>.tableView.tableHeaderView = <span class="keyword">self</span>.tableView.tableHeaderView</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>完整Demo</strong>: <a href="https://github.com/aunnnn/TableHeaderViewWithAutoLayout" target="_blank" rel="noopener">TableHeaderViewWithAutoLayout</a></p><h2 id="Extension"><a href="#Extension" class="headerlink" title="Extension"></a>Extension</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UITableView</span> </span>&#123;</span><br><span class="line">    <span class="comment">//set the tableHeaderView so that the required height can be determined, update the header's frame and set it again</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setAndLayoutTableHeaderView</span><span class="params">(header: UIView)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.tableHeaderView = header</span><br><span class="line">        header.setNeedsLayout()</span><br><span class="line">        header.layoutIfNeeded()</span><br><span class="line">        header.frame.size = header.systemLayoutSizeFittingSize(<span class="type">UILayoutFittingCompressedSize</span>)</span><br><span class="line">        <span class="keyword">self</span>.tableHeaderView = header</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> header = <span class="type">SCAMessageView</span>()</span><br><span class="line">header.titleLabel.text = <span class="string">"Warning"</span></span><br><span class="line">header.subtitleLabel.text = <span class="string">"Warning message here."</span></span><br><span class="line">tableView.setAndLayoutTableHeaderView(header)</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://medium.com/@aunnnn/table-header-view-with-autolayout-13de4cfc4343" target="_blank" rel="noopener">Table header view with AutoLayout</a></li><li><a href="https://stackoverflow.com/questions/16471846/is-it-possible-to-use-autolayout-with-uitableviews-tableheaderview" target="_blank" rel="noopener">Is it possible to use AutoLayout with UITableView’s tableHeaderView?</a></li><li><a href="https://stackoverflow.com/questions/28079591/using-autolayout-in-a-tableheaderview" target="_blank" rel="noopener">Using autolayout in a tableHeaderView</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我一直在寻找如何在 &lt;code&gt;tableHeaderView&lt;/code&gt; 使用AutoLayout。设置  &lt;code&gt;tableView&lt;/code&gt; 的 &lt;code&gt;tableHeaderView&lt;/code&gt; 感觉就像在黑洞中投掷视图一样。我们不知道它与层次结构中
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://www.devorz.com/tags/iOS/"/>
    
      <category term="AutoLayout" scheme="https://www.devorz.com/tags/AutoLayout/"/>
    
      <category term="UI" scheme="https://www.devorz.com/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>A successful Git branching model</title>
    <link href="https://www.devorz.com/2019/04/18/A-successful-Git-branching-model/"/>
    <id>https://www.devorz.com/2019/04/18/A-successful-Git-branching-model/</id>
    <published>2019-04-18T12:46:05.000Z</published>
    <updated>2019-05-15T18:18:21.145Z</updated>
    
    <content type="html"><![CDATA[<p>原文: <a href="https://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">A successful Git branching model</a><br><img src="https://ws2.sinaimg.cn/large/006tNc79gy1g32jsa2ocyj30u013rq9f.jpg" alt=""></p><h2 id="Why-git"><a href="#Why-git" class="headerlink" title="Why git?"></a>Why git?</h2><p>有关Git与集中式源代码控制系统相比的利弊的详细讨论，请参阅<a href="https://git.wiki.kernel.org/index.php/GitSvnComparsion" target="_blank" rel="noopener">网站</a>。那里战火纷飞。作为开发人员，我喜欢Git超过所有的其他工具。 Git 真的改变了开发人员对合并和分支的看法。在 古老的的 CVS / Subversion 世界里，合并/分支一直被认为有点可怕（“小心合并冲突，它们会咬你”），但是你每隔一段时间都要做。 </p><p>但是使用Git，这些操作非常容易和简单，并且它们被认为是你日常工作流程的核心部分之一。例如，在 CVS / Subversion <a href="http://svnbook.red-bean.com/" target="_blank" rel="noopener">书籍</a>中，分支和合并通常在最后的章节才第一次谈论（对于高级用户），而在<a href="https://pragprog.com/titles/tsgit/pragmatic-version-control-using-git" target="_blank" rel="noopener">每本Git书</a>中，它已经在第3章（基础知识）中介绍过了。</p><p>由于其简单性和重复性，分支和合并不再是一件令人害怕的事情。版本控制工具应该比其他任何东西更有助于分支/合并。</p><p>准备好工具，让我们进入开发模型。我将在这里介绍的模型基本上只是每个团队成员必须遵循的一组步骤以便来管理软件开发过程。</p><h2 id="Decentralized-but-centralized"><a href="#Decentralized-but-centralized" class="headerlink" title="Decentralized but centralized"></a>Decentralized but centralized</h2><p>我们使用的仓库设置与该分支模型配合良好，具有一个“真实”中央仓库。请注意，这个仓库只被认为是中央仓库（因为Git是DVCS，在技术层面没有中央仓库）。我们将此repo称为origin，所有Git用户应该都熟悉此名称。<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1g278cksfygj30r20k23zf.jpg" alt=""></p><p>每个开发人员都会pull并puch 到 origin。但除了集中式 push-pull 关系之外，每个开发人员还可以从其他同行中获取更改以形成子团队。例如，在将正在进行的工作过早地推送到 origin 中之前，这对于与两个或更多开发人员一起处理大型新功能可能是有用的。在上图中，有 Alice 和 Bob，Alice 和 David 以及 Clair和David 的子团队。</p><p>从技术上讲，这意味着Alice已经定义了一个名为 bob 的Git remote，指向Bob的仓库，反之亦然。</p><h2 id="The-main-branches"><a href="#The-main-branches" class="headerlink" title="The main branches"></a>The main branches</h2><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1g32jtzw6y4j30eu0mc3zu.jpg" alt=""><br>事实上，这个开发模型受到现有模型的极大启发。中央仓库拥有两个主要分支，具有无限的生命周期：</p><ul><li>master</li><li>develop</li></ul><p>origin 上的 master 分支每个Git用户应该都熟悉。与 master(本地) 分支并行，另一个分支称为develop。</p><p>我们认为 origin/master 是主分支，其中HEAD的源代码总是反映生产就绪状态。</p><p>我们将 origin/develop 视为主要分支，而它的 HEAD 指针始终指向为下一发版而做的最新开发改动。有些人称之为“整合分支”(integration branch)。这是建立任何自动夜间构建的地方。</p><p>当 develop 分支中的源代码达到稳定点并准备好发布时，所有更改都应以某种方式合并回master，然后使用版本号进行标记。具体如何做我们将进一步讨论。</p><p>因此，每次将更改合并回master时，根据定义，这是一个新的生产版本。我们对此非常严格，因此从理论上讲，我们可以使用Git钩子脚本在每次有master提交时自动构建和推出我们的软件到我们的生产服务器。</p><h2 id="Supporting-branches"><a href="#Supporting-branches" class="headerlink" title="Supporting branches"></a>Supporting branches</h2><p>主干分支<code>master</code>和<code>develop</code>之外，我们的开发模型使用了很多辅助分支来帮助团队成员间的并行开发，减轻功能跟踪的成本，预备生产环境的发布，协助快速修复已发布版本的问题。和主干分支相反，这些辅助分支只有有限的生命期，最终会被移除。</p><p>我们可能会用到的辅助分支有：</p><ul><li>Feature branches</li><li>Release branches</li><li>Hotfix branches</li></ul><p>上面的每个辅助分支都有一个特定的目标，且严格限制哪些是起源分支，哪些是合并的目标分支。我们一会儿会详细解释。</p><p>从技术角度来看，这些分支绝不是”特殊的”。分支的类型是按照我们如何使用它们而划分的，也就是普通的 Git 分支而已。</p><h3 id="Feature-branches"><a href="#Feature-branches" class="headerlink" title="Feature branches"></a>Feature branches</h3><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1g319pe1spzj307e0juq3i.jpg" alt=""></p><ul><li>可以从 <strong>develop</strong> 派生。</li><li>必须合并到 <strong>develop</strong> 分支。</li><li>分支命名公约： 除 master 、develop、 release-<em> 和 hotfix-</em> 以外的任意命名。</li></ul><p>Feature 分支（有时称为 topic 分支），是用来为未来的发版而开发新 features 的分支。当开始 feature 的开发时，。Feature 分支的本质它会在 feature 的开发期内存在，但最终会合并回 <code>develop</code> 分支（一定会在即将发布的版本中添加新功能），或者被直接丢弃掉（在令人失望的试验的情况下）。</p><p>Feature 分支通常仅存在于开发人员的 repos 中，而不在 <code>origin</code> 中。</p><h4 id="Creating-a-release-branch"><a href="#Creating-a-release-branch" class="headerlink" title="Creating a release branch"></a>Creating a release branch</h4><p>要创建一个新的 Feature 分支，从 develop 分支上派生：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git checkout -b myfeature develop</span><br><span class="line">Switched to a new branch "myfeature"</span><br></pre></td></tr></table></figure><h4 id="Incorporating-a-finished-feature-on-develop-¶"><a href="#Incorporating-a-finished-feature-on-develop-¶" class="headerlink" title="Incorporating a finished feature on develop ¶"></a>Incorporating a finished feature on develop <a href="https://nvie.com/posts/a-successful-git-branching-model/#incorporating-a-finished-feature-on-develop" target="_blank" rel="noopener">¶</a></h4><p>完成的功能可以合并到<code>develop</code>分支中，以确保将它们添加到即将发布的版本中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git checkout develop</span><br><span class="line">Switched to branch 'develop'</span><br><span class="line"><span class="meta">$</span> git merge --no-ff myfeature</span><br><span class="line">Updating ea1b82a..05e9557</span><br><span class="line">(Summary of changes)</span><br><span class="line"><span class="meta">$</span> git branch -d myfeature</span><br><span class="line">Deleted branch myfeature (was 05e9557).</span><br><span class="line"><span class="meta">$</span> git push origin develop</span><br></pre></td></tr></table></figure><p><code>--no-ff</code> 标识使得 merge 操作总是创建一个新的 commit，即使 merge 可以使用 fast-forward。这避免了 feature 分支历史信息的丢失，而且把所有 commit 归并在一起。比较一下：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1g319zhtmqcj30qk0nijsu.jpg" alt=""></p><p>后者无法从 Git 历史中找到是哪些 commit 实现了 feature，你必须要手工的去阅读所有的 log 信息。撤销一个 feature 在后一种情况下真的很头疼，如果使用了<code>--no-ff</code>标志，很容易做到。</p><p>是的，它会创建一些（空的）提交对象，但增益远远大于成本。</p><h3 id="Release-branches"><a href="#Release-branches" class="headerlink" title="Release branches"></a>Release branches</h3><ul><li>可以 <strong>develop</strong> 分支派生。</li><li>必须合并回 <strong>develop</strong> 和 <strong>master</strong> 分支。</li><li>分支命名公约: release-*</li></ul><p>Release 分支为新的生产版本做预备。最后的画龙点睛。此外，Release 分支也可以用来修复小 bug 和准备发布版本的元数据（版本号，构建日期等）。通过在 Release 分支上完成所有这些工作，develop 分支将清晰明了，以便接收下一个大版本的发布。</p><p>从 <code>develop</code> 分支新发布分支的关键时刻是开发（几乎）反映新版本的期望状态。。至少所有针对要构建的版本的功能在此时必须已经合并进 <code>develop</code>。针对未来版本的所有功能可能不会 – 他们必须等到<code>release</code>分支派生后。</p><p>确切的说，release 分支始于即将发布的一个版本分配了一个版本号–不能提早。直到那一刻之前，develop 分支反映出“next release” 的改动。但还不清楚“下一次发布”最终是否会变成0.3或1.0，对 release 版本的决定是在 release 分支开始时，由项目的版本号规则来拟定。</p><h4 id="Creating-a-release-branch-1"><a href="#Creating-a-release-branch-1" class="headerlink" title="Creating a release branch"></a>Creating a release branch</h4><p>Release 分支是从develop分支创建的。例如，当前的生产版本是 1.15，且即将有一个大迭代。develop 分支的状态已经为 next release 做好准备，我们也已经决定好即将到来的版本是 1.2（而不是 1.1.6或者2.0）。因此我们从当前的 develop 分支上派生并给他起一个反应了新版本号的名字：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git checkout -b release-1.2 develop</span><br><span class="line">Switched to a new branch "release-1.2"</span><br><span class="line"><span class="meta">$</span> ./bump-version.sh 1.2</span><br><span class="line">Files modified successfully, version bumped to 1.2.</span><br><span class="line"><span class="meta">$</span> git commit -a -m "Bumped version number to 1.2"</span><br><span class="line">[release-1.2 74d9424] Bumped version number to 1.2</span><br><span class="line">1 files changed, 1 insertions(+), 1 deletions(-)</span><br></pre></td></tr></table></figure><p>创建并切换到新分支后，我们遇到了版本号。在这里，bump-version.sh 是一个虚拟出来的 shell 脚本，用来修改一些文件，使其能体现新版本。之后，遇到的版本号被 commit 上去。</p><p>该新分支可能会存在一段时间，直到 release 可以确定被发布出来。在此期间，分支上可能会修复一些 bug（而不是在 develop 分支上）。严禁在该分支上添加大的 feature 进来。release 分支最后必须被 merge 回 develop 分支上，然后继续等待下一个大版本的发布。</p><h4 id="Finishing-a-release-branch"><a href="#Finishing-a-release-branch" class="headerlink" title="Finishing a release branch"></a>Finishing a release branch</h4><p>当 release 分支的开发状态到了真正可以发布的时候，就需要采取一些行动了。首先， release 分支得 merge 到 master 分支（记住，master 上的每个 commit 都是一个定义的新的 release）。然后，提交到 master 上的 commit 必须被标记上 Tag，以便将来参考该历史版本。最后，release 分支上的改动还需要 merge 回 develop 分支，以便以后的 release 也包含这些 bug fixes。</p><p>两步 Git 操作:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git checkout master</span><br><span class="line">Switched to branch 'master'</span><br><span class="line"><span class="meta">$</span> git merge --no-ff release-1.2</span><br><span class="line">Merge made by recursive.</span><br><span class="line">(Summary of changes)</span><br><span class="line"><span class="meta">$</span> git tag -a 1.2</span><br></pre></td></tr></table></figure><p>现在，release 已经完成，并且标记了 Tag。</p><p>（你可能还想使用 -s 或 -u <key> 来对 Tag 进行加密）</key></p><p>为了保留 release 分支上的改动，继续将他们 merge 回 develop 分支，Git 操作如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git checkout develop</span><br><span class="line">Switched to branch 'develop'</span><br><span class="line"><span class="meta">$</span> git merge --no-ff release-1.2</span><br><span class="line">Merge made by recursive.</span><br><span class="line">(Summary of changes)</span><br></pre></td></tr></table></figure><p>这些操作可能会带来代码冲突（很可能，自我们改变了版本号以来），尝试解决冲突后再提交。<br>现在，我们已经彻底完成工作并且 release 分支已经可以被移除了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git branch -d release-1.2</span><br><span class="line">Deleted branch release-1.2 (was ff452fe).</span><br></pre></td></tr></table></figure><h3 id="Hotfix-branches"><a href="#Hotfix-branches" class="headerlink" title="Hotfix branches"></a>Hotfix branches</h3><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1g32j1ufu7pj30hk0no75z.jpg" alt=""><br>从 <strong>master</strong> 分支派生；<br>必须 merge 回 <strong>develop</strong> 分支和 <strong>master</strong> 分支；<br>分支命名公约：hotfix-*</p><p>Hotfix 分支和 release 分支很类似，都是为发布新的生产版本而准备，虽然是计划外的。其存在的必要性是由于当前生产版本处于需要紧急修复的状态。当生产版本发生严重 bug 必须立即修复时，hotfix 分支可以从生产版本的 master 分支上的相应 Tag 派生出来。</p><p>这样做的本质是在 develop 分支上开发的人员可以继续，另一边，其他人员则可以快速的进行生产版本的修复工作。</p><h4 id="Creating-the-hotfix-branch"><a href="#Creating-the-hotfix-branch" class="headerlink" title="Creating the hotfix branch"></a>Creating the hotfix branch</h4><p>Hotfix 分支从 master 派生。比如，当前线上运行的生产版本是 1.2 版，遇到严重 bug，但是 develop 分支上的版本还不到稳定版，就可以派生 hotfix 分支然后开始修复问题：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git checkout -b hotfix-1.2.1 master</span><br><span class="line">Switched to a new branch "hotfix-1.2.1"</span><br><span class="line"><span class="meta">$</span> ./bump-version.sh 1.2.1</span><br><span class="line">Files modified successfully, version bumped to 1.2.1.</span><br><span class="line"><span class="meta">$</span> git commit -a -m "Bumped version number to 1.2.1"</span><br><span class="line">[hotfix-1.2.1 41e61bb] Bumped version number to 1.2.1</span><br><span class="line">1 files changed, 1 insertions(+), 1 deletions(-)</span><br></pre></td></tr></table></figure><p>别忘了在派生分支后的版本号。</p><p>然后，一个或者分多次修复 bug 并提交上去：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git commit -m "Fixed severe production problem"</span><br><span class="line">[hotfix-1.2.1 abbe5d6] Fixed severe production problem</span><br><span class="line">5 files changed, 32 insertions(+), 17 deletions(-)</span><br></pre></td></tr></table></figure><h4 id="Finishing-a-hotfix-branch"><a href="#Finishing-a-hotfix-branch" class="headerlink" title="Finishing a hotfix branch"></a>Finishing a hotfix branch</h4><p>完成后，bug修复需要合并到 master 分支上，同时还得 合并到 develop 分支，以保证 bugfix 也包含在下一个版本中 ，这和 release 分支的结束过程是非常类似的。</p><p>首先，更新master ，然后为新的 release 标记 Tag：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git checkout master</span><br><span class="line">Switched to branch 'master'</span><br><span class="line"><span class="meta">$</span> git merge --no-ff hotfix-1.2.1</span><br><span class="line">Merge made by recursive.</span><br><span class="line">(Summary of changes)</span><br><span class="line"><span class="meta">$</span> git tag -a 1.2.1</span><br></pre></td></tr></table></figure><p>（你可能还想使用 -s 或 -u <key> 来对 Tag 进行加密）</key></p><p>然后， develop 分支也包含这些 bugfixs：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git checkout develop</span><br><span class="line">Switched to branch 'develop'</span><br><span class="line"><span class="meta">$</span> git merge --no-ff hotfix-1.2.1</span><br><span class="line">Merge made by recursive.</span><br><span class="line">(Summary of changes)</span><br></pre></td></tr></table></figure><p>有一个例外的原则是，如果当前有一个 release 分支存在，那么 hotfix 分支上的改动需要合并到 release 分支，而不是 develop 分支。当 release 分支结束时，合并到 release 分支上的修复代码最终还是会合并到 develop 上。</p><p>最后，移除这个临时分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git branch -d hotfix-1.2.1</span><br><span class="line">Deleted branch hotfix-1.2.1 (was abbe5d6).</span><br></pre></td></tr></table></figure><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>虽然这个分支模型并没有什么令人耳目一新的新功能，但这篇文章开头的“大图”在我们的项目中非常有用。它构造了易于理解并允许团队成员开发公共分支和发布流程的优雅模型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文: &lt;a href=&quot;https://nvie.com/posts/a-successful-git-branching-model/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A successful Git branching model&lt;/a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>What’s New in Swift 5?</title>
    <link href="https://www.devorz.com/2019/04/04/What-s-New-in-Swift5/"/>
    <id>https://www.devorz.com/2019/04/04/What-s-New-in-Swift5/</id>
    <published>2019-04-04T14:55:55.000Z</published>
    <updated>2019-04-06T12:13:23.961Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://www.raywenderlich.com/55728-what-s-new-in-swift-5" target="_blank" rel="noopener">What’s New in Swift 5?</a></p></blockquote><p>Swift 5 最终伴随着Xcode 10.2一起到来。这次发布带来了 ABI 稳定性 并且改进了语言，一些期待已久的特性。来看看这些新东西吧！</p><p>在这篇教程，你将学习Swift 5的一些重大改变。使用 Swift 5 需要Xcode 10.2，所以在开始前请确认你安装了它。</p><h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><p>Swift 5 源兼容(source compatible) Swift 4.2，但是它不二进制兼容（binary compatible）更早的Swift 发行版。不过由于 ABI 稳定性，未来发行版将与Swift 5二进制兼容。</p><p>ABI 稳定性让使用不同 Swift版本编译的应用程序和库之间的二进制兼容性。Swift 标准库和运行时嵌入在 OS 中，因此应用程序不会在任何平台上分发自己的库副本。这导致更好的 工具解耦(tool decoupling) 和 OS 集成(OS integration)。</p><p>你还需要 ABI 稳定性来分发跨多个 Swift 版本的二进制frameworks(binary frameworks )。这需要模块格式稳定性(module format stability)，稳定模块包含编译器的框架公开接口表示的模块文件。</p><p>你可以在本教程的每个章节找到 <a href="https://apple.github.io/swift-evolution/" target="_blank" rel="noopener">Swift Evolution</a>像 [SE-0001] 这样的提议号。你可以浏览每个提案的链接来详细了解每项新变化。</p><p>最好是在 playground 中尝试这些新特性。</p><p>启动 Xcode 10.2，选择 File ▸ New ▸ Playground，在 platform 项选择 <strong>iOS</strong> ，template 选 <strong>Blank</strong> 。命名和保存位置随意，你开心就好。开始吧！</p><blockquote><p>需要快速复习一下 Swift 4.2 重点，查看 Swift 4.2教程。<a href="https://www.raywenderlich.com/5357-what-s-new-in-swift-4-2" target="_blank" rel="noopener">What’s New in Swift 4.2?</a></p></blockquote><h2 id="Language-Improvements"><a href="#Language-Improvements" class="headerlink" title="Language Improvements"></a>Language Improvements</h2><p>Swift 5有很多语言特性，如 动态可调用类型(dynamic callable types),处理未来的枚举(handling future enumeration)等等.</p><h3 id="Testing-Integer-Multiples"><a href="#Testing-Integer-Multiples" class="headerlink" title="Testing Integer Multiples"></a>Testing Integer Multiples</h3><p>在Swift 4.2中，你可以使用余数运算符确定数字是否是另一个的倍数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstNumber = <span class="number">4</span></span><br><span class="line"><span class="keyword">let</span> secondNumber = <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> secondNumber != <span class="number">0</span> &amp;&amp; firstNumber % secondNumber == <span class="number">0</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"\(secondNumber) * \(firstNumber / secondNumber) = \(firstNumber)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码如何工作：</p><ol><li>确认 <code>secondNumber</code> 不为 0.</li><li>确认 <code>firstNumber</code>除以<code>secondNumber</code>余 0.</li><li>执行除法操作。</li></ol><p>你必须确认 <code>secondNumber</code> 不为 0,否则 % 操作将抛出错误。</p><p>Swift 5 通过给<code>BinaryInteger</code>添加了 <code>isMultiple(of:)</code> 方法简化了这一操作<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0225-binaryinteger-iseven-isodd-ismultiple.md" target="_blank" rel="noopener">SE-0225</a>:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> firstNumber.isMultiple(of: secondNumber) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"\(secondNumber) * \(firstNumber / secondNumber) = \(firstNumber)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使你传入 0 作为参数,<code>isMultiple(of:)</code>依然可以工作，而且是代码更加简洁明了。</p><h3 id="Escaping-Raw-Strings"><a href="#Escaping-Raw-Strings" class="headerlink" title="Escaping Raw Strings"></a>Escaping Raw Strings</h3><p>Swift 4.2使用转义符来表示字符串中的反斜杠和引号：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> escape = <span class="string">"You use escape sequences for \"quotes\"\\\"backslashes\" in Swift 4.2."</span></span><br><span class="line"><span class="keyword">let</span> multiline = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">                You use escape sequences for \"\"\"quotes\"\"\"\\\"\"\"backslashes\"\"\"</span></span><br><span class="line"><span class="string">                on multiple lines</span></span><br><span class="line"><span class="string">                in Swift 4.2.</span></span><br><span class="line"><span class="string">                "</span><span class="string">""</span></span><br></pre></td></tr></table></figure><p>Swift 5添加了 raw strings 。你可以在字符串的开头和结尾添加＃，这样你就可以使用反斜杠和引号而不会出现问题:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> raw = #<span class="string">"You can create "</span>raw<span class="string">"\"plain"</span> strings <span class="keyword">in</span> <span class="type">Swift</span> <span class="number">5</span>.<span class="string">"#</span></span><br><span class="line"><span class="string">let multiline = #"</span><span class="string">""</span></span><br><span class="line">                <span class="type">You</span> can create <span class="string">""</span><span class="string">"raw"</span><span class="string">""</span>\<span class="string">""</span><span class="string">"plain"</span><span class="string">""</span> strings</span><br><span class="line">                on multiple lines</span><br><span class="line">                <span class="keyword">in</span> <span class="type">Swift</span> <span class="number">5</span>.</span><br><span class="line">                <span class="string">""</span><span class="string">"#</span></span><br></pre></td></tr></table></figure><p>在原始字符串中使用字符串插值时，必须在反斜杠后使用 # 号：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> track = <span class="string">"Nothing Else Matters"</span></span><br><span class="line"><span class="built_in">print</span>(#<span class="string">"My favorite tune\song is \#(track)."</span>#)</span><br></pre></td></tr></table></figure><p>在某些情况下，你需要在字符串的开头和结尾使用多个＃：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hashtag = ##<span class="string">"You can use the Swift "</span>hashtag<span class="string">" #swift in Swift 5."</span>##</span><br></pre></td></tr></table></figure><p>在上面的代码中，你在开头添加##在 <code>hashtag</code>结尾添加 #，这样可以在字符串中表示＃。字符串开头使用的 # 数量必须与其末尾的数量相同。</p><p>在Swift 4.2中，你在正则表达式中转义反斜杠，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> versions = <span class="string">"3 3.1 4 4.1 4.2 5"</span></span><br><span class="line"><span class="keyword">let</span> range = <span class="type">NSRange</span>(versions.startIndex..., <span class="keyword">in</span>: versions)</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> regex = <span class="keyword">try</span>! <span class="type">NSRegularExpression</span>(pattern: <span class="string">"\\d\\.\\d"</span>)</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">let</span> minorVersions = regex.matches(<span class="keyword">in</span>: versions, range: range)</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line">minorVersions.forEach &#123; <span class="built_in">print</span>(versions[<span class="type">Range</span>($<span class="number">0</span>.range, <span class="keyword">in</span>:  versions)!]) &#125;</span><br></pre></td></tr></table></figure><ol><li>声明 <code>versions</code>定义一个 <code>range</code> 覆盖整个字符串</li><li>定义一个匹配 <code>versions</code> 中所有次要Swift发行版(minor Swift releases)的正则表达式。</li><li>使用<code>matches(in:options:range:)</code>确定次要发行版的rangs 。</li><li>使用 <code>rangs</code> 从 <code>versions</code>中获得次要发行版。</li></ol><p>Swift 5使用 <code>raw strings</code> 简化正则表达式:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="keyword">try</span>! <span class="type">NSRegularExpression</span>(pattern: #<span class="string">"\d\.\d"</span>#)</span><br></pre></td></tr></table></figure><p>在上述代码中，你定义 <code>regex</code>用的反斜杠少了一半，因为你不需要在 <code>raw strings</code> 中转义反斜杠。</p><p><a href="https://koenig-media.raywenderlich.com/uploads/2018/05/swift.png" target="_blank" rel="noopener"><img src="https://koenig-media.raywenderlich.com/uploads/2018/05/swift-320x320.png" alt="No extra backslashes in regular expressions!"></a>  </p><blockquote><p>需要了解更多的关于正则表达式如何在Swift中使用，请看这篇教程: <a href="https://www.raywenderlich.com/5767-an-introduction-to-regular-expressions" target="_blank" rel="noopener">An Introduction to Regular Expressions</a></p></blockquote><h3 id="Using-New-Character-Properties"><a href="#Using-New-Character-Properties" class="headerlink" title="Using New Character Properties"></a>Using New Character Properties</h3><p>在处理<code>characters</code>时，Swift 4.2 需要一个解决方法来处理一个常见的需求：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="string">"ID10"</span></span><br><span class="line"><span class="keyword">var</span> digits = <span class="number">0</span></span><br><span class="line">id.forEach &#123; digits += <span class="type">Int</span>(<span class="type">String</span>($<span class="number">0</span>)) != <span class="literal">nil</span> ? <span class="number">1</span> : <span class="number">0</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Id has \(digits) digits."</span>)</span><br></pre></td></tr></table></figure><p>在此代码中，首先将每个字符转换为String，然后再转换为Int，以确定 id 有多少数字。</p><p>但是，Swift 5为Character添加了属性，使 characters 更易用<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0221-character-properties.md" target="_blank" rel="noopener">SE-0221</a>:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id.forEach &#123; digits += $<span class="number">0</span>.isNumber ? <span class="number">1</span> : <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure><p>在上述情况中，你使用 <code>isNumber</code> 来检查每个字符是否都是数字。查看提案来寻找其他你能使用的属性。</p><h3 id="Using-New-Unicode-Scalar-Properties"><a href="#Using-New-Unicode-Scalar-Properties" class="headerlink" title="Using New Unicode Scalar Properties"></a>Using New Unicode Scalar Properties</h3><p>在 Swift4.2 中，你为Unicode scalars 实现文本处理算法，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> username = <span class="string">"bond007"</span></span><br><span class="line"><span class="keyword">var</span> letters = <span class="number">0</span></span><br><span class="line">username.unicodeScalars.forEach &#123; </span><br><span class="line">  letters += (<span class="number">65</span>...<span class="number">90</span>) ~= $<span class="number">0</span>.value || (<span class="number">97</span>...<span class="number">122</span>) ~= $<span class="number">0</span>.value ? <span class="number">1</span> : <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Username has \(letters) letters."</span>)</span><br></pre></td></tr></table></figure><p>在此代码中，您通过检查每个字符的 <code>unicode scalars</code>是代表小写字母还是大写字母来计算用户名的字母数。</p><p>Swift 5为 <code>unicode scalars</code> 添加了属性，简化了文本处理<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0211-unicode-scalar-properties.md" target="_blank" rel="noopener">SE-0211</a>:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username.unicodeScalars.forEach &#123; letters += $<span class="number">0</span>.properties.isAlphabetic ? <span class="number">1</span> : <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure><p>在此代码中，你使用<code>isAlphabetic</code> 检查每个字符是否为数字。链接的提案将显示你可以检查的所有属性。</p><h3 id="Removing-Subsequences"><a href="#Removing-Subsequences" class="headerlink" title="Removing Subsequences"></a>Removing Subsequences</h3><p>Swift 4.2 使用下列方法 从 <code>Sequence</code> <code>customization points</code>返回 <code>SubSequence</code>:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(<span class="number">_</span> s: String)</span></span> -&gt; <span class="type">SubSequence</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> n = <span class="type">Int</span>(s) <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">dropLast</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dropLast</span>(n)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sequence = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">4</span>]</span><br><span class="line">sequence.remove(<span class="string">"2"</span>) <span class="comment">// [5, 2]</span></span><br><span class="line">sequence.remove(<span class="string">"two"</span>) <span class="comment">// [5, 2, 7]</span></span><br></pre></td></tr></table></figure><p>上述情况中，如果 s 是一个 <code>Int</code>那么 <code>remove(_:)</code>将从 <code>sequence</code>移除倒数的 n 个元素,否则移除最后一个元素。</p><p>Swift 5用 <code>sequences</code> 中的具体类型替换<code>SubSequence</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(<span class="number">_</span> s: String)</span></span> -&gt; [<span class="type">Element</span>] &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> n = <span class="type">Int</span>(s) <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">dropLast</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dropLast</span>(n)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，<code>remove(_:)</code> 跟随 <code>dropLast()</code> 和 <code>dropLast(_:)</code> 一样返回 <code>[Element]</code>类型。</p><h2 id="Dictionary-Updates"><a href="#Dictionary-Updates" class="headerlink" title="Dictionary Updates"></a>Dictionary Updates</h2><p>Swift 5为 Dictionary 带来了许多期待已久的改进:</p><h3 id="Compacting-Dictionaries"><a href="#Compacting-Dictionaries" class="headerlink" title="Compacting Dictionaries"></a>Compacting Dictionaries</h3><p>Swift 4.2使用 <code>mapValues</code>,<code>filter</code>和 <code>reduce</code>来从过滤 Dictionary 中的 nil 值：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> students = [<span class="string">"Oana"</span>: <span class="string">"10"</span>, <span class="string">"Nori"</span>: <span class="string">"ten"</span>]</span><br><span class="line"><span class="keyword">let</span> filterStudents = students.mapValues(<span class="type">Int</span>.<span class="keyword">init</span>)</span><br><span class="line">  .<span class="built_in">filter</span> &#123; $<span class="number">0</span>.value != <span class="literal">nil</span> &#125;</span><br><span class="line">  .mapValues &#123; $<span class="number">0</span>! &#125;</span><br><span class="line"><span class="keyword">let</span> reduceStudents = students.<span class="built_in">reduce</span>(into: [:]) &#123; $<span class="number">0</span>[$<span class="number">1</span>.key] = <span class="type">Int</span>($<span class="number">1</span>.value) &#125;</span><br></pre></td></tr></table></figure><p>上述代码使用 <code>mapValues</code>加上<code>mapValues</code>或者 <code>reduce</code> 来认定 <code>students</code>中成绩有效的学生。<br>两种方法都需要多次通过 <code>dictionary</code>而且使代码复杂化。</p><p>Swift 5 使用 <code>compactMapValues(_:)</code>来高效解决<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0218-introduce-compact-map-values.md" target="_blank" rel="noopener">[SE-0218]</a>:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mapStudents = students.compactMapValues(<span class="type">Int</span>.<span class="keyword">init</span>)</span><br></pre></td></tr></table></figure><p>使用更少的代码行数完成了相同的事情，整洁！</p><h3 id="Renaming-Dictionary-Literals"><a href="#Renaming-Dictionary-Literals" class="headerlink" title="Renaming Dictionary Literals"></a>Renaming Dictionary Literals</h3><p>Swift 4.2使用 <code>DictionaryLiteral</code>来来声明一个Dictionary:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pets: <span class="type">DictionaryLiteral</span> = [<span class="string">"dog"</span>: <span class="string">"Sclip"</span>, <span class="string">"cat"</span>: <span class="string">"Peti"</span>]</span><br></pre></td></tr></table></figure><p>DictionaryLiteral 不是一个 Dictionary 也不是 literal. 它是一个键值对表。</p><p>Swift 5 重命名 <code>DictionaryLiteral</code> 为 <code>KeyValuePairs</code><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0214-DictionaryLiteral.md" target="_blank" rel="noopener">[SE-0214]</a>:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pets: <span class="type">KeyValuePairs</span> = [<span class="string">"dog"</span>: <span class="string">"Sclip"</span>, <span class="string">"cat"</span>: <span class="string">"Peti"</span>]</span><br></pre></td></tr></table></figure><h2 id="Numeric-Protocol-Updates"><a href="#Numeric-Protocol-Updates" class="headerlink" title="Numeric Protocol Updates"></a>Numeric Protocol Updates</h2><p>Swift 4.2为向量实现了 <code>Numeric</code>:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x, y: <span class="type">Int</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">init</span>(<span class="number">_</span> x: <span class="type">Int</span>, <span class="number">_</span> y: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.x = x</span><br><span class="line">    <span class="keyword">self</span>.y = y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Vector</span>: <span class="title">ExpressibleByIntegerLiteral</span> </span>&#123;</span><br><span class="line">  <span class="keyword">init</span>(integerLiteral value: <span class="type">Int</span>) &#123;</span><br><span class="line">    x = value</span><br><span class="line">    y = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Vector</span>: <span class="title">Numeric</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> magnitude: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Int</span>(sqrt(<span class="type">Double</span>(x * x + y * y)))</span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>?&lt;<span class="type">T</span>&gt;(exactly value: <span class="type">T</span>) &#123;</span><br><span class="line">    x = value <span class="keyword">as</span>! <span class="type">Int</span></span><br><span class="line">    y = value <span class="keyword">as</span>! <span class="type">Int</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> +<span class="params">(lhs: Vector, rhs: Vector)</span></span> -&gt; <span class="type">Vector</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Vector</span>(lhs.x + rhs.x, lhs.y + rhs.y)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> +=<span class="params">(lhs: <span class="keyword">inout</span> Vector, rhs: Vector)</span></span> &#123;</span><br><span class="line">    lhs = lhs + rhs</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> -<span class="params">(lhs: Vector, rhs: Vector)</span></span> -&gt; <span class="type">Vector</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Vector</span>(lhs.x - rhs.x, lhs.y - rhs.y)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> -=<span class="params">(lhs: <span class="keyword">inout</span> Vector, rhs: Vector)</span></span> &#123;</span><br><span class="line">    lhs = lhs - rhs</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> *<span class="params">(lhs: Vector, rhs: Vector)</span></span> -&gt; <span class="type">Vector</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Vector</span>(lhs.x * rhs.y, lhs.y * rhs.x)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> *=<span class="params">(lhs: <span class="keyword">inout</span> Vector, rhs: Vector)</span></span> &#123;</span><br><span class="line">    lhs = lhs * rhs</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Vector</span>: <span class="title">CustomStringConvertible</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"(\(x) \(y))"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码如何工作：</p><ol><li><p>为 <code>vector</code> 声明<code>x</code>，<code>y</code>和 <code>init(_:_:)</code>。</p></li><li><p>实现 <code>init(integerLiteral:)</code>方法来使 <code>Vector</code> 遵守 <code>Numeric</code>必须遵守的 <code>ExpressibleByIntegerLiteral</code>。</p></li><li>定义 vector 的<code>magnitude</code>使其符合 <code>Numeric</code>,声明 <code>init(exactly:)</code>然后实现 <code>+(lhs:rhs:)</code>, <code>+=(lhs:rhs:)</code>, <code>-(lhs:rhs:)</code>, <code>-=(lhs:rhs:)</code>, <code>*(lhs:rhs:)</code>, <code>*=(lhs:rhs:)</code>。</li><li>实现 <code>description</code> 使 <code>Vector</code>  遵守 <code>CustomStringConvertible</code>。</li></ol><p>上面的代码使你可以轻松地使用 vector :</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> first = <span class="type">Vector</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// (1,2)</span></span><br><span class="line"><span class="keyword">let</span> second = <span class="type">Vector</span>(<span class="number">3</span>, <span class="number">4</span>) <span class="comment">// (3,4)</span></span><br><span class="line"><span class="keyword">let</span> third = first + second <span class="comment">// (4,6)</span></span><br><span class="line">first += second <span class="comment">// (4,6)</span></span><br><span class="line"><span class="keyword">let</span> fourth = first - second <span class="comment">// (1,2)</span></span><br><span class="line">first -= second <span class="comment">// (1,2)</span></span><br></pre></td></tr></table></figure><p>Swift 5为 vector 实现 <code>AdditiveArithmetic</code>，因为你无法定义2D向量的叉积。<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0233-additive-arithmetic-protocol.md" target="_blank" rel="noopener">[SE-0233]</a>。它在 <code>ExpressibleByIntegerLiteral</code> 中不是必须的:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Vector</span>: <span class="title">AdditiveArithmetic</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">var</span> zero: <span class="type">Vector</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Vector</span>(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> +<span class="params">(lhs: Vector, rhs: Vector)</span></span> -&gt; <span class="type">Vector</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Vector</span>(lhs.x + rhs.x, lhs.y + rhs.y)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> +=<span class="params">(lhs: <span class="keyword">inout</span> Vector, rhs: Vector)</span></span> &#123;</span><br><span class="line">    lhs = lhs + rhs</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> -<span class="params">(lhs: Vector, rhs: Vector)</span></span> -&gt; <span class="type">Vector</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Vector</span>(lhs.x - rhs.x, lhs.y - rhs.y)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> -=<span class="params">(lhs: <span class="keyword">inout</span> Vector, rhs: Vector)</span></span> &#123;</span><br><span class="line">    lhs = lhs - rhs</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码，你通过定义 <code>zero</code>和实现 <code>+(lhs:rhs:)</code>, <code>+=(lhs:rhs:)</code>, <code>-(lhs:rhs:)</code>, <code>-=(lhs:rhs:)</code>。</p><p><a href="https://koenig-media.raywenderlich.com/uploads/2018/12/announcement.png" target="_blank" rel="noopener"><img src="https://koenig-media.raywenderlich.com/uploads/2018/12/announcement.png" alt="Working with vectors is so easy in Swift 5!"></a>  </p><blockquote><p>想学习更多关于Swift中的操作符重载，访问操作符重载的教程<a href="https://www.raywenderlich.com/650-overloading-custom-operators-in-swift" target="_blank" rel="noopener">Overloading Custom Operators in Swift</a></p></blockquote><h2 id="String-Interpolation-Updates"><a href="#String-Interpolation-Updates" class="headerlink" title="String Interpolation Updates"></a>String Interpolation Updates</h2><p>Swift 4.2 通过 <code>interpolating segments</code> 实现 字符串的插入:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> language = <span class="string">"Swift"</span></span><br><span class="line"><span class="keyword">let</span> languageSegment = <span class="type">String</span>(stringInterpolationSegment: language)</span><br><span class="line"><span class="keyword">let</span> space = <span class="string">" "</span></span><br><span class="line"><span class="keyword">let</span> spaceSegment = <span class="type">String</span>(stringInterpolationSegment: space)</span><br><span class="line"><span class="keyword">let</span> version = <span class="number">4.2</span></span><br><span class="line"><span class="keyword">let</span> versionSegment = <span class="type">String</span>(stringInterpolationSegment: version)</span><br><span class="line"><span class="keyword">let</span> string = <span class="type">String</span>(stringInterpolation: languageSegment, spaceSegment, versionSegment)</span><br></pre></td></tr></table></figure><p>在上述代码，首先包裹每个部分加入<code>init(stringInterpolationSegment:)</code>，然后把所有的部分用 <code>init(stringInterpolation:)</code>包起来。</p><p>Swift 5带来了完全不同的处理方法<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0228-fix-expressiblebystringinterpolation.md" target="_blank" rel="noopener">[SE-0228]</a>:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> interpolation = <span class="type">DefaultStringInterpolation</span>(</span><br><span class="line">  literalCapacity: <span class="number">7</span>,</span><br><span class="line">  interpolationCount: <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> language = <span class="string">"Swift"</span></span><br><span class="line">interpolation.appendLiteral(language)</span><br><span class="line"><span class="keyword">let</span> space = <span class="string">" "</span></span><br><span class="line">interpolation.appendLiteral(space)</span><br><span class="line"><span class="keyword">let</span> version = <span class="number">5</span></span><br><span class="line">interpolation.appendInterpolation(version)</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">let</span> string = <span class="type">String</span>(stringInterpolation: interpolation)</span><br></pre></td></tr></table></figure><p>这段代码做了什么：</p><ol><li>用指定容量和插入计数定义了一个 <code>DefaultStringInterpolation</code>实例。</li><li>调用 <code>appendLiteral(_:)</code>和 <code>appendInterpolation(_:)</code>来添加文字和插入数值到<code>interpolation</code>。</li><li>通过调用 <code>init(stringInterpolation:)</code>生成最终的插值字符串。</li></ol><h2 id="Handling-Future-Enumeration-Cases"><a href="#Handling-Future-Enumeration-Cases" class="headerlink" title="Handling Future Enumeration Cases"></a>Handling Future Enumeration Cases</h2><p>Swift 4.2 不能恰当的处理新的枚举值，看下面的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Post</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> tutorial, article, screencast, course</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readPost</span><span class="params">(<span class="number">_</span> post: Post)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> post &#123;</span><br><span class="line">    <span class="keyword">case</span> .tutorial:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"You are reading a tutorial."</span></span><br><span class="line">    <span class="keyword">case</span> .article:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"You are reading an article."</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"You are watching a video."</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">let</span> screencast = <span class="type">Post</span>.screencast</span><br><span class="line">readPost(screencast) <span class="comment">// "You are watching a video."</span></span><br><span class="line"><span class="keyword">let</span> course = <span class="type">Post</span>.course</span><br><span class="line">readPost(course) <span class="comment">// "You are watching a video."</span></span><br></pre></td></tr></table></figure><p>上面的代码发生了什么：</p><ol><li>定义了所有的网站上的 blog posts 类型。</li><li>添加 <code>default</code>使 <code>switch</code>无遗漏。</li><li>在 <code>default</code> 中处理 <code>.screencast</code> 和<code>.course</code>因为他们都是视频。</li></ol><p>以下是在Swift 4.2中处理 <code>podcasts</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Post</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> tutorial, article, podcast, screencast, course</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> podcast = <span class="type">Post</span>.podcast</span><br><span class="line">readPost(podcast) <span class="comment">// "You are watching a video."</span></span><br></pre></td></tr></table></figure><p>上述代码中，你在 <code>default</code>中处理<code>.podcast</code>,<br>即使它不是视频，Swift不会报警告因为 <code>switch</code>没有遗漏。</p><p>Swift 5关注到了新增枚举的情况<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0192-non-exhaustive-enums.md" target="_blank" rel="noopener">[SE-0192]</a>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readPost</span><span class="params">(<span class="number">_</span> post: BlogPost)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> post &#123;</span><br><span class="line">    <span class="keyword">case</span> .tutorial:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"You are reading a tutorial."</span></span><br><span class="line">    <span class="keyword">case</span> .article:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"You are reading an article."</span></span><br><span class="line">    @unknown <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"You are reading a blog post."</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readPost(screencast) <span class="comment">// "You are reading a blog post."</span></span><br><span class="line">readPost(course) <span class="comment">// "You are reading a blog post."</span></span><br><span class="line">readPost(podcast) <span class="comment">// "You are reading a blog post."</span></span><br></pre></td></tr></table></figure><p>在这段代码中，你标记用<code>@unknown</code><br>标记 <code>default</code>，Swift 将会警告你<code>switch</code>是不详尽的。<code>default</code>处理 <code>.screencast</code>, <code>.course</code>和<code>.podcast</code><br>，因为他们都是 blog posts。</p><p><a href="https://koenig-media.raywenderlich.com/uploads/2018/05/sun.png" target="_blank" rel="noopener"><img src="https://koenig-media.raywenderlich.com/uploads/2018/05/sun-320x320.png" alt="The future is bright for Swift 5 enumerations!"></a>  </p><h2 id="Adding-Result-to-the-Standard-Library"><a href="#Adding-Result-to-the-Standard-Library" class="headerlink" title="Adding Result to the Standard Library"></a>Adding Result to the Standard Library</h2><p>Swift 5 加入 <code>Result</code>到标准库<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0235-add-result.md" target="_blank" rel="noopener"> [SE-0235]</a>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ConnectionError</span>: <span class="title">Error</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> noNetwork, noDatabase</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> networkSuccess = <span class="type">Result</span>&lt;<span class="type">String</span>, <span class="type">ConnectionError</span>&gt;.success(<span class="string">"Network connected!"</span>)</span><br><span class="line"><span class="keyword">let</span> databaseSuccess = <span class="type">Result</span>&lt;<span class="type">String</span>, <span class="type">ConnectionError</span>&gt;.success(<span class="string">"Database connected!"</span>)</span><br><span class="line"><span class="keyword">let</span> networkFailure = <span class="type">Result</span>&lt;<span class="type">String</span>, <span class="type">ConnectionError</span>&gt;.failure(.noNetwork)</span><br><span class="line"><span class="keyword">let</span> databaseFailure = <span class="type">Result</span>&lt;<span class="type">String</span>, <span class="type">ConnectionError</span>&gt;.failure(.noDatabase)</span><br><span class="line"><span class="keyword">let</span> sameSuccess = networkSuccess == databaseSuccess</span><br><span class="line"><span class="keyword">let</span> sameFailure = networkFailure == databaseFailure</span><br><span class="line"><span class="keyword">let</span> success: <span class="type">Set</span> = [networkSuccess, databaseSuccess]</span><br><span class="line"><span class="keyword">let</span> failure: <span class="type">Set</span> = [networkFailure, databaseFailure]</span><br><span class="line"><span class="keyword">let</span> successDictionary = [</span><br><span class="line">  networkSuccess: <span class="keyword">try</span>! networkSuccess.<span class="keyword">get</span>(),</span><br><span class="line">  databaseSuccess: <span class="keyword">try</span>! databaseSuccess.<span class="keyword">get</span>()</span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> failureDictionary = [</span><br><span class="line">  networkFailure: <span class="type">ConnectionError</span>.noNetwork,</span><br><span class="line">  databaseFailure: <span class="type">ConnectionError</span>.noDatabase</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这段代码如何工作：</p><ol><li>声明最常见的连接错误.</li><li>比较连接结果，将它们添加到集合中。你可以使用这些集和中的元素作为字典的 key ，因为Result实现了 <code>Equatable</code>和 <code>Hashable</code>。</li></ol><h2 id="Conforming-Never-to-Equatable-and-Hashable"><a href="#Conforming-Never-to-Equatable-and-Hashable" class="headerlink" title="Conforming Never to Equatable and Hashable"></a>Conforming Never to Equatable and Hashable</h2><p>Swift 5 是 <code>Never</code> 遵从 <code>Equatable</code>和<code>Hashable</code><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0215-conform-never-to-hashable-and-equatable.md" target="_blank" rel="noopener">[SE-0215]</a><br>:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> alwaysSucceeds = <span class="type">Result</span>&lt;<span class="type">String</span>, <span class="type">Never</span>&gt;.success(<span class="string">"Network connected!"</span>)</span><br><span class="line"><span class="keyword">let</span> neverFails = <span class="type">Result</span>&lt;<span class="type">String</span>, <span class="type">Never</span>&gt;.success(<span class="string">"Database connected!"</span>)</span><br><span class="line"><span class="keyword">let</span> alwaysFails = <span class="type">Result</span>&lt;<span class="type">Never</span>, <span class="type">ConnectionError</span>&gt;.failure(.noNetwork)</span><br><span class="line"><span class="keyword">let</span> neverSucceeds = <span class="type">Result</span>&lt;<span class="type">Never</span>, <span class="type">ConnectionError</span>&gt;.failure(.noDatabase)</span><br><span class="line"><span class="keyword">let</span> sameValue = alwaysSucceeds == neverFails</span><br><span class="line"><span class="keyword">let</span> sameError = alwaysFails == neverSucceeds</span><br><span class="line"><span class="keyword">let</span> alwaysSuccess: <span class="type">Set</span> = [alwaysSucceeds, neverFails]</span><br><span class="line"><span class="keyword">let</span> alwaysFailure: <span class="type">Set</span> = [alwaysFails, neverSucceeds]</span><br><span class="line"><span class="keyword">let</span> alwaysSuccessDictionary = [</span><br><span class="line">  alwaysSucceeds: <span class="keyword">try</span>! alwaysSucceeds.<span class="keyword">get</span>(),</span><br><span class="line">  neverFails: <span class="keyword">try</span>! neverFails.<span class="keyword">get</span>()</span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> alwaysFailureDictionary = [</span><br><span class="line">  alwaysFails: <span class="type">ConnectionError</span>.noNetwork,</span><br><span class="line">  neverSucceeds: <span class="type">ConnectionError</span>.noDatabase</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在此代码中，您定义连接结果的返回值或错误，比较它们，将它们添加到集合并将它们用作字典key。</p><h2 id="Dynamically-Callable-Types"><a href="#Dynamically-Callable-Types" class="headerlink" title="Dynamically Callable Types"></a>Dynamically Callable Types</h2><p>Swift 5定义了 <code>dynamically callable types</code>,使其可以与 <code>Python</code> 和 <code>Ruby</code>相互操作。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">@dynamicCallable</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicFeatures</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">dynamicallyCall</span><span class="params">(withArguments params: [Int])</span></span> -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">guard</span> !params.isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> params.<span class="built_in">reduce</span>(<span class="number">0</span>, +)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">dynamicallyCall</span><span class="params">(withKeywordArguments params: KeyValuePairs&lt;String, Int&gt;)</span></span> -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">guard</span> !params.isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> params.<span class="built_in">reduce</span>(<span class="number">0</span>) &#123; $<span class="number">1</span>.key.isEmpty ? $<span class="number">0</span> : $<span class="number">0</span> + $<span class="number">1</span>.value &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">let</span> features = <span class="type">DynamicFeatures</span>()</span><br><span class="line">features() <span class="comment">// nil</span></span><br><span class="line">features(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">// 12</span></span><br><span class="line">features(first: <span class="number">3</span>, <span class="number">4</span>, second: <span class="number">5</span>) <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><p>上述代码：</p><ol><li>用 <code>@dynamicCallable</code> 标记 <code>DynamicFeatures</code> 使其成为 <code>dynamically callable type</code></li><li>使 <code>DynamicFeatures</code> 遵从 <code>@dynamicCallable</code> ,实现 <code>dynamicallyCall(withArguments:)</code> 和 <code>dynamicallyCall(withKeywordArguments:)</code>。</li><li>使用平常的语法调用 <code>features</code>，编译器将调用<code>dynamicallyCall(withArguments:)</code> 或者<code>dynamicallyCall(withKeywordArguments:)</code> 。</li></ol><h2 id="Swift-Package-Manager-Updates"><a href="#Swift-Package-Manager-Updates" class="headerlink" title="Swift Package Manager Updates"></a>Swift Package Manager Updates</h2><p>Swift 5给 Swift Package Manager添加了一些特性：</p><h3 id="Platform-Deployment-Settings"><a href="#Platform-Deployment-Settings" class="headerlink" title="Platform Deployment Settings"></a>Platform Deployment Settings</h3><p>Swift 5允许您在 Package.swift 中定义所需的最低平台部署目标版本<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0236-package-manager-platform-deployment-settings.md" target="_blank" rel="noopener">[SE-0236]</a>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> package = <span class="type">Package</span>(name: “<span class="type">Package</span>”, platforms: [</span><br><span class="line">  .macOS(.v10_14), </span><br><span class="line">  .iOS(.v12),</span><br><span class="line">  .tvOS(.v12), </span><br><span class="line">  .watchOS(.v5)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>你可以在 <code>SupportedPlatform</code>中使用 <code>macOS（）</code>，<code>iOS（）</code>，<code>tvOS（）</code>和<code>watchOS（）</code>来设置包所需的最低平台版本。</p><h3 id="Target-Build-Settings"><a href="#Target-Build-Settings" class="headerlink" title="Target Build Settings"></a>Target Build Settings</h3><p>Swift 5在 Package.swift 中声明了特定于目标的构建设置。它们自定义包管理器在目标构建期间如何调用构建工具<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0238-package-manager-build-settings.md" target="_blank" rel="noopener">[SE-0238]</a>。</p><h3 id="Dependency-Mirroring"><a href="#Dependency-Mirroring" class="headerlink" title="Dependency Mirroring"></a>Dependency Mirroring</h3><p>Swift 5为Swift Package Manager带来了依赖镜像 [<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0219-package-manager-dependency-mirroring.md" target="_blank" rel="noopener">SE-0219</a>].</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift package config set-mirror --package-url &lt;package&gt; --mirror-url &lt;mirror&gt;</span><br></pre></td></tr></table></figure><p>即使原始源不可用或被删除，镜像也允许您访问依赖项。</p><p><code>set-mirror</code>使用镜像更新依赖项，后者替换所有其他镜像。</p><p>使用<code>unset-mirror</code>从依赖项中删除镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">swift package config unset-mirror --package-url &lt;package&gt;</span><br><span class="line">swift package config unset-mirror —mirror-url &lt;mirror&gt; </span><br><span class="line">swift package config unset-mirror --all</span><br></pre></td></tr></table></figure><h2 id="Miscellaneous-Bits-and-Pieces"><a href="#Miscellaneous-Bits-and-Pieces" class="headerlink" title="Miscellaneous Bits and Pieces"></a>Miscellaneous Bits and Pieces</h2><p>  Swift 5还增加了一些其他急需的功能和改进：</p><h3 id="Making-Codable-Ranges"><a href="#Making-Codable-Ranges" class="headerlink" title="Making Codable Ranges"></a>Making Codable Ranges</h3><p>  Swift 5 给 rangs 增加了 Codable 的遵从 [<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0239-codable-range.md" target="_blank" rel="noopener">SE-0239</a>]:</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> temperature = <span class="number">0</span>...<span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> encoder = <span class="type">JSONEncoder</span>()</span><br><span class="line"><span class="keyword">let</span> data = <span class="keyword">try</span>! encoder.encode(temperature)</span><br><span class="line"><span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()</span><br><span class="line"><span class="keyword">let</span> temperatureRange = <span class="keyword">try</span>! decoder.decode(<span class="type">ClosedRange</span>&lt;<span class="type">Int</span>&gt;.<span class="keyword">self</span>, from: data)</span><br></pre></td></tr></table></figure><p>您使用JSONEncoder对温度进行编码并使用JSONDecoder解码数据，因为默认情况下,rangs 在Swift 5中实现了 Codable 。</p><h3 id="Flattening-Nested-Optionals"><a href="#Flattening-Nested-Optionals" class="headerlink" title="Flattening Nested Optionals"></a>Flattening Nested Optionals</h3><p>  Swift 4.2 使用 <code>try?</code>创建 Nested Optionals：</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">DivisionError</span>: <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> divisionByZero</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">divideBy</span><span class="params">(<span class="number">_</span> number: Int)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> number != <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="type">DivisionError</span>.divisionByZero</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span> / number</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">let</span> number: <span class="type">Int</span>? = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> division = <span class="keyword">try</span>? number?.divideBy(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> division = division, </span><br><span class="line">   <span class="keyword">let</span> <span class="keyword">final</span> = division &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="keyword">final</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码：</p><ol><li>用 <code>DivisionError</code> 扩展 <code>Int</code> 。</li><li>如果 <code>number</code>为 0 ,<code>divideBy(_:)</code> 抛出 <code>.divisionByZero</code>。</li><li>解开 <code>division</code> 两次，因为它是一个 <code>Int ??</code> 型。</li></ol><p> Swift 5以不同的方式处理[<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0230-flatten-optional-try.md" target="_blank" rel="noopener">SE-0230</a>]:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> division = division &#123;</span><br><span class="line">  <span class="built_in">print</span>(division)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>try?</code> 在Swift 5中不会创建 nested optionals ，因此你需要解包一次，因为它是一个 <code>Int？</code>型</p><h3 id="Removing-Customization-Points-From-Collections"><a href="#Removing-Customization-Points-From-Collections" class="headerlink" title="Removing Customization Points From Collections"></a>Removing Customization Points From Collections</h3><p> 在Swift 4.2  你入口可以从 <code>Collection</code>中自定义细节(customization points)：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> first: <span class="type">Element</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> !isEmpty ? <span class="keyword">self</span>[<span class="built_in">count</span> - <span class="number">1</span>] : <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> last: <span class="type">Element</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> !isEmpty ? <span class="keyword">self</span>[<span class="number">0</span>] : <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> names = [<span class="string">"Cosmin"</span>, <span class="string">"Oana"</span>, <span class="string">"Sclip"</span>, <span class="string">"Nori"</span>]</span><br><span class="line">names.first <span class="comment">// "Nori"</span></span><br><span class="line">names.last <span class="comment">// "Cosmin"</span></span><br></pre></td></tr></table></figure><p>在此代码中，<code>first</code> 从 <code>names</code>返回最后一个名字，<code>last</code> 返回数组的第一个元素。</p><p>两个计算属性都不能按预期工作，因此 Swift 5 会从集合中删除自定义细节 [<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0232-remove-customization-points.md" target="_blank" rel="noopener">SE-0232</a>]<br>。</p><h3 id="Identity-Key-Paths"><a href="#Identity-Key-Paths" class="headerlink" title="Identity Key Paths"></a>Identity Key Paths</h3><p>Swift 4.2使用<code>.self</code>来访问值:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tutorial</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> title: <span class="type">String</span></span><br><span class="line">  <span class="keyword">let</span> author: <span class="type">String</span></span><br><span class="line">  <span class="keyword">init</span>(title: <span class="type">String</span>, author: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.title = title</span><br><span class="line">    <span class="keyword">self</span>.author = author</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tutorial = <span class="type">Tutorial</span>(title: <span class="string">"What's New in Swift 5.0?"</span>, author: <span class="string">"Cosmin Pupaza"</span>)</span><br><span class="line">tutorial.<span class="keyword">self</span> = <span class="type">Tutorial</span>(title: <span class="string">"What's New in Swift 5?"</span>, author: <span class="string">"Cosmin Pupăză"</span>)</span><br></pre></td></tr></table></figure><p>在此代码中，你使用 <code>.self</code> 一口气更改教程的标题和作者。</p><p>Swift 5 添加为 <strong>identity key paths</strong> 来访问值 [<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0227-identity-keypath.md" target="_blank" rel="noopener">SE-0227</a>];</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tutorial[keyPath: \.<span class="keyword">self</span>] = <span class="type">Tutorial</span>(</span><br><span class="line">  title: <span class="string">"What's New in Swift 5?"</span>,</span><br><span class="line">  author: <span class="string">"Cosmin Pupăză"</span>)</span><br></pre></td></tr></table></figure><p>在此代码中，您使用<code>\ .self</code>来更新 <code>tutorial</code>。</p><h3 id="Initializing-Literals-Through-Coercion"><a href="#Initializing-Literals-Through-Coercion" class="headerlink" title="Initializing Literals Through Coercion"></a>Initializing Literals Through Coercion</h3><p>在Swift 5中，如果类型符合 literal 协议，则<code>literal initializers</code>会将字面值强制转换为其类型:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="type">UInt64</span>(<span class="number">0xFFFF_FFFF_FFFF_FFFF</span>)</span><br></pre></td></tr></table></figure><p>在Swift 4.2中，上面的代码行在编译时产生溢出错误。</p><h3 id="Build-Configuration-Updates"><a href="#Build-Configuration-Updates" class="headerlink" title="Build Configuration Updates"></a>Build Configuration Updates</h3><p>Swift 4.2 条件编译时用 <code>&gt;=</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> favoriteNumber = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> evenNumber = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> !swift(&gt;=<span class="number">5</span>)</span><br><span class="line">  evenNumber = favoriteNumber % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">#<span class="keyword">else</span> </span><br><span class="line">  evenNumber = favoriteNumber.isMultiple(of: <span class="number">2</span>)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> !compiler(&gt;=<span class="number">5</span>)</span><br><span class="line">  evenNumber = favoriteNumber % <span class="number">2</span> == <span class="number">0</span>  </span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">  evenNumber = favoriteNumber.isMultiple(of: <span class="number">2</span>)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>这些条件检查Swift版本是否大于或等于5，并在满足条件时编译这些代码。</p><p>Swift 5增加 <code>&lt;</code> 用来更简洁的表达条件 [<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0224-ifswift-lessthan-operator.md" target="_blank" rel="noopener">SE-0224</a>]:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">if</span> swift(&lt;<span class="number">5</span>)</span><br><span class="line">  evenNumber = favoriteNumber % <span class="number">2</span> == <span class="number">0</span>   </span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">  evenNumber = favoriteNumber.isMultiple(of: <span class="number">2</span>)  </span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> compiler(&lt;<span class="number">5</span>)</span><br><span class="line">  evenNumber = favoriteNumber % <span class="number">2</span> == <span class="number">0</span> </span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">  evenNumber = favoriteNumber.isMultiple(of: <span class="number">2</span>)   </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h3 id="Using-Variadic-Parameters-for-Enumeration-Cases-With-Associated-Values"><a href="#Using-Variadic-Parameters-for-Enumeration-Cases-With-Associated-Values" class="headerlink" title="Using Variadic Parameters for Enumeration Cases With Associated Values"></a>Using Variadic Parameters for Enumeration Cases With Associated Values</h3><p>Swift 4.2中，在有关联值时，你可以使用可变参数来枚举case:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">BlogPost</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> tutorial(<span class="number">_</span>: <span class="type">String</span>...)</span><br><span class="line">  <span class="keyword">case</span> article(<span class="number">_</span>: <span class="type">String</span>...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以使用 <code>String ...</code> 获取 tutorials 和 articles 详细信息。这在 Swift 5 中是不行的，所以你应该使用数组：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">BlogPost</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> tutorial([<span class="type">String</span>])</span><br><span class="line">  <span class="keyword">case</span> article([<span class="type">String</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Deprecating-String-Index-Encoded-Offsets"><a href="#Deprecating-String-Index-Encoded-Offsets" class="headerlink" title="Deprecating String Index Encoded Offsets"></a>Deprecating String Index Encoded Offsets</h3><p> Swift 4.2字符串使用UTF-16编码。因此，encodedOffset将返回UTF-16字符串的偏移量：</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> swiftVersion = <span class="string">"Swift 4.2"</span></span><br><span class="line"><span class="keyword">let</span> offset = swiftVersion.endIndex.encodedOffset</span><br></pre></td></tr></table></figure><p> 在这段代码 你可以获得 <code>swiftVersion</code> 中 <code>endIndex</code> 的偏移量。这不适用于Swift 5中使用的UTF-8字符串编码，因此Swift 5用<code>utf16Offset（in :)</code>替换<code>encodedOffset</code>来处理这两种情况:</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> swiftVersion = <span class="string">"Swift 5"</span></span><br><span class="line"><span class="keyword">let</span> offset = swiftVersion.endIndex.utf16Offset(<span class="keyword">in</span>: swiftVersion)</span><br></pre></td></tr></table></figure><h3 id="New-Pointer-Methods"><a href="#New-Pointer-Methods" class="headerlink" title="New Pointer Methods"></a>New Pointer Methods</h3><p>Swift 5添加了 <code>ContiguousStorageIfAvailable（_ :)</code>到 <code>Sequence</code> 和 <code>withContiguousMutableStorageIfAvailable（_ :)</code> 到 <code>MutableCollection</code>，为协议扩展中的 <code>withUnsafeBufferPointer（_ :)</code>和<code>withUnsafeMutableBufferPointer（_ :)</code>提供通用实现[<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0237-contiguous-collection.md" target="_blank" rel="noopener">SE-0237</a>]。</p><h3 id="SIMD-Vector-Updates"><a href="#SIMD-Vector-Updates" class="headerlink" title="SIMD Vector Updates"></a>SIMD Vector Updates</h3><p> Swift 5将处理器的SIMD类型操作添加到标准库中。它们为 SIMD vectors 和矩阵提供底层支持。它们还简化了&lt;simd/simd.h&gt;的Objective-C，C和C实现[<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0229-simd.md" target="_blank" rel="noopener">SE-0229</a>].</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://www.raywenderlich.com/55728-what-s-new-in-swift-5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;What’s New in Swift 
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://www.devorz.com/tags/iOS/"/>
    
      <category term="Swift" scheme="https://www.devorz.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Dell U2518DR 开启HiDPI</title>
    <link href="https://www.devorz.com/2018/11/14/Dell-U2518DR-HiDPI/"/>
    <id>https://www.devorz.com/2018/11/14/Dell-U2518DR-HiDPI/</id>
    <published>2018-11-14T08:49:37.000Z</published>
    <updated>2018-11-14T10:47:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自iPhone 4s 上市，到前不久的新款 MacBook Air 发布，苹果产品线正式进入了全线 Retina 的时代。习惯了 Retina 屏的果粉在挑选外接屏幕时，一般都会将最低标准定在 4K 分辨率以保证良好的清晰度。<br>    本人由于家境贫寒，只能用 “三米抗锯齿，五米全高清”来安慰自己，于今年光棍节在二手东购入 Dell U2518DR。后显示效果不佳，查阅各种资料开启 HiDPI 后略有改善，特此记录。</p><h2 id="关闭SIP"><a href="#关闭SIP" class="headerlink" title="关闭SIP"></a>关闭SIP</h2><ol><li>重启Mac，按住 Command + R 进入 Recovery 模式。</li><li>在工具栏的 实用工具 里找到终端 ，打开终端输入 <code>csrutil disable</code> .</li><li>重启Mac, 打开终端后输入 <code>csrutil status</code> 可以看到SIP状态。<code>System Integrity Protection status: disabled.</code>即表示 SIP 成功关闭。</li></ol><h2 id="开启HiDPI"><a href="#开启HiDPI" class="headerlink" title="开启HiDPI"></a>开启HiDPI</h2><ol><li>打开终端运行 <code>sudo defaults write /Library/Preferences/com.apple.windowserver.plist DisplayResolutionEnabled -bool true</code> 开启 HiDPI 模式。</li><li><p>运行 <code>ioreg -lw0 | grep IODisplayPrefsKey</code> 得到如下结果：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;IODisplayPrefsKey&quot; = &quot;IOService:/AppleACPIPlatformExpert/PCI0@0/AppleACPIPCI/IGPU@2/AppleIntelFramebuffer@0/display0/AppleBacklightDisplay-610-a019&quot;</span><br><span class="line">&quot;IODisplayPrefsKey&quot; = &quot;IOService:/AppleACPIPlatformExpert/PCI0@0/AppleACPIPCI/PEG0@1/IOPP/GFX0@0/ATY,Berbice@3/AMDFramebufferVIB/display0/AppleDisplay-10ac-413c&quot;</span><br></pre></td></tr></table></figure><p> 记下第二行末的 10ac 和 413c 备用，它们分别是 DisplayVendorId 和 DisplayProductID。<br><strong>注意，开启HiDPI需要关闭U2518DR的 Smart HDR，否则DisplayProductID将为 413d且下述方法无法开启HiDPI,原因未知</strong></p></li><li><p>打开 <a href="https://comsysto.github.io/Display-Override-PropertyList-File-Parser-and-Generator-with-HiDPI-Support-For-Scaled-Resolutions/" target="_blank" rel="noopener">显示器配置生成网址</a>，DisplayProductName     改为 DELL U2518DR ，DisplayProductID 改为 413c ，DisplayVendorID 改为 10ac ，下载配置文件。</p></li><li><p>打开终端运行 <code>sudo cp ~/Downloads/DisplayProductID-413c.plist /System/Library/Displays/Contents/Resources/Overrides/DisplayVendorID-10ac/DisplayProductID-413c</code>替换配置文件。</p></li><li><p>重启电脑，安装并打开 <a href="http://avi.alkalay.net/software/RDM/" target="_blank" rel="noopener">DRM</a>,设置分辨率为 1920x1080。如下图即大功告成， <img src="https://i.loli.net/2018/11/14/5bebf0e8538c1.jpg" alt=""></p></li><li><p>重复关闭 SIP 中的步骤，把步骤2中的 <code>csrutil disable</code> 换成 <code>csrutil enable</code>重新打开 SIP。</p></li></ol><h2 id="SwitchResX"><a href="#SwitchResX" class="headerlink" title="SwitchResX"></a>SwitchResX</h2><p>坦率的讲，如果使用 <a href="www.madrau.com">SwitchResX</a>(需要梯子) 开启 HiDPI会方便很多。网上也有教程自行搜索。但是该软件16刀的售价着实让家境清寒的我负担不起。<br>如果你已经安装SwitchResX，首先打开 SwitchResX ，在工具栏找到 Uninstall 将其卸载 <img src="https://i.loli.net/2018/11/14/5bebf3dcdb9c0.png" alt="">如果显示器色彩配置以及关于本机显示器中仍有 “SwitchResX4-”字样，删除 <code>/Library/Preferences/.GlobalPreferences.plist</code>重启Mac即可。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>开启Smart HDR后无法打开的HiDPI的原因暂时未知。</p><p>破解 SwitchResX ？ 破解是不可能破解的，这辈子都不可能盗版的。</p><p>付费？即使在是16刀的支持开发者的精神照耀下，开启HiDPI后的2K显示器还有和Retina有着显著的区别。</p><p>所以，有那个闲钱还是攒钱上4K吧！<a href="https://www.apple.com/cn/shop/product/HKMY2CH/A?fnode=52d4e9533d4a9fa4c4b4faeeb91482f1c317d3eaf7dc15cbd0afc2c1437dc3d63d1c8dfb8762e150b7af8b7ac50e9144f2e55c2248329fd0a7248b955eb0d3ed6c09762a0f34b22cc8134195150bd63610511aa9a5e655998df0b1297f788dea" target="_blank" rel="noopener">LG UltraFine 4K</a>真香！</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.zhihu.com/question/35300978" target="_blank" rel="noopener">请教一下如何在 Mac OS X 10.11 下开启自定义 HiDPI？</a><br><a href="https://www.v2ex.com/t/322204" target="_blank" rel="noopener">DELL U2515H（ 2K） 开启 1920X1080 HiDPI</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;自iPhone 4s 上市，到前不久的新款 MacBook Air 发布，苹果产品线正式进入了全线 Retina 的时代。习惯了 Retin
      
    
    </summary>
    
    
      <category term="外设" scheme="https://www.devorz.com/tags/%E5%A4%96%E8%AE%BE/"/>
    
      <category term="硬件" scheme="https://www.devorz.com/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>小米路由器Pro 打开SSH 安装 MT 工具箱</title>
    <link href="https://www.devorz.com/2018/08/24/miwifi-shadowsocks/"/>
    <id>https://www.devorz.com/2018/08/24/miwifi-shadowsocks/</id>
    <published>2018-08-24T09:56:48.000Z</published>
    <updated>2019-04-05T16:46:29.392Z</updated>
    
    <content type="html"><![CDATA[<p>打开 SSH，安装 Misstar Tools，安装所需插件。</p><a id="more"></a><h2 id="路由器刷入开发版ROM"><a href="#路由器刷入开发版ROM" class="headerlink" title="路由器刷入开发版ROM"></a>路由器刷入开发版ROM</h2><p>进入 <a href="http://www1.miwifi.com/miwifi_download.html" target="_blank" rel="noopener">MiWiFi-下载</a> 选择对应的路由器信号的开发版 ROM 进行下载。<br>进入 <a href="http://192.168.31.1/" target="_blank" rel="noopener">路由器设置页面</a>,常用设置-&gt;系统状态-&gt;升级检测 点击手动升级，选择刚刚下载的固件上传开始升级。</p><p><img src="https://i.loli.net/2018/08/24/5b7fdb380df1a.png" alt="update"></p><p>完成后进入路由器设置页，看到路由器信息显示固件为开发版<br><img src="https://i.loli.net/2018/08/24/5b7fdb865fe1e.png" alt="开发版"></p><h2 id="开启-SSH"><a href="#开启-SSH" class="headerlink" title="开启 SSH"></a>开启 SSH</h2><p>使用小米账号绑定路由器。<br>打开<a href="http://d.miwifi.com/rom/ssh" target="_blank" rel="noopener">MiWiFi-SSH</a>下载工具包</p><p><img src="https://i.loli.net/2018/08/24/5b7fdcaf8cadc.jpg" alt=""></p><blockquote><p>开启SSH将失去保修。</p></blockquote><ol><li>请将下载的工具包bin文件复制到U盘（FAT/FAT32格式）的根目录下，保证文件名为miwifi_ssh.bin；</li><li>断开小米路由器的电源，将U盘插入USB接口；</li><li>按住reset按钮之后重新接入电源，指示灯变为黄色闪烁状态即可松开reset键；</li><li>等待3-5秒后安装完成之后，小米路由器会自动重启，之后您就可以尽情折腾啦 ：）</li></ol><blockquote><p>实测第三步需保证重启后路由器与外网连接，否则SSH无法开启。（猜想应该是用来提交SN码到小米服务器，标记开启SSH,失去保修资格）</p></blockquote><p>PS: 不知道为什么小米路由器这种辣鸡我为什么买了3台。自带劫持作呕。<br><img src="https://i.loli.net/2018/08/24/5b7fdd4e88a47.png" alt="劫持"></p><h2 id="安装-Misstar-Tools"><a href="#安装-Misstar-Tools" class="headerlink" title="安装 Misstar Tools"></a>安装 Misstar Tools</h2><p>工具箱简介：</p><blockquote><p>MT工具箱是目前第三方插件里面最为方便易用的插件集合，往往我们以前安装各种插件，都要一个个在SSH里面安装并且还一个个设置都是比较麻烦的！MT工具箱给我们提供一个整体的框架，在工具箱里面的每个插件都是独立的。所以我们可以自由选择需要自己安装的插件，并且可以单独更新插件。MT工具箱直接集成在路由器后台页面，只有安装的时候需要一行SSH命令，往后的插件安装卸载升级都只需要在这一个后台页面进行，全图形化操作，特别的方便！有问题的时候不用再经常使用SSH去查看每个插件的运行状况和设置了！并且工具箱是免疫OTA升级的，可以放心更新系统，工具箱依然坚挺的存在！</p></blockquote><p>使用 <code>ssh root@192.168.31.1</code>连接路由器，输入 <a href="http://d.miwifi.com/rom/ssh" target="_blank" rel="noopener">MiWiFi-SSH</a> 页面得到的 root 密码。</p><p>如果正常进去路由器，将得到如下页面</p><p><img src="https://i.loli.net/2018/08/24/5b7fe0bc3dfbe.png" alt="ssh"></p><blockquote><p>彩蛋：猴王金曲</p></blockquote><p>如果提示 <code>connection refused</code> 考虑是 SSH 未开启成功。可以重试开启 SSH 部分的操作。并使用 <code>nmap</code> 命令验证 22 端口是否开启。</p><p><img src="https://i.loli.net/2018/08/24/5b7fe0896035c.png" alt="ssh验证"></p><p>使用 <code>passwd</code> 命令修改 root 密码。</p><p>使用如下命令安装工具箱：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.misstar.com/tools/appstore/install.sh -O /tmp/install.sh &amp;&amp; chmod a+x /tmp/install.sh &amp;&amp; /tmp/install.sh</span><br></pre></td></tr></table></figure><p>刷新设置页，导航栏出现 MT工具箱。</p><p><img src="https://i.loli.net/2018/08/24/5b7fe1e8689f8.png" alt="MT工具箱"></p><p>如果需要卸载，使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.misstar.com/tools/uninstall.sh -O /tmp/uninstall.sh &amp;&amp; chmod +x /tmp/uninstall.sh &amp;&amp; /tmp/uninstall.sh</span><br></pre></td></tr></table></figure><blockquote><p>2019/03/31 Update：</p></blockquote><p>由于站点 <code>www.misstar.com</code>现已开始3.0内测，并开启全站https,且原有2.0已经从站点移除，所以现在使用上述上述命令会提示 <code>wget: not an http or ftp url: https://www.misstar.com/tools/appstore/install.sh</code>;现在需要使用<a href="http://cloud.lifeheart.cn:188/miwifi/MT/" target="_blank" rel="noopener">分流站</a>安装/卸载：</p><p>安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://cloud.lifeheart.cn:188/miwifi/MT/tools/appstore/install.sh -O /tmp/install.sh &amp;&amp; chmod +x /tmp/install.sh &amp;&amp; /tmp/install.sh</span><br></pre></td></tr></table></figure><p>卸载:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://cloud.lifeheart.cn:188/miwifi/MT/tools/appstore/uninstall.sh -O /tmp/uninstall.sh &amp;&amp; chmod +x /tmp/uninstall.sh &amp;&amp; /tmp/uninstall.sh</span><br></pre></td></tr></table></figure><h2 id="安装-Shadowsocks"><a href="#安装-Shadowsocks" class="headerlink" title="安装 Shadowsocks"></a>安装 Shadowsocks</h2><p>打开 MT 插件管理页，使用开发者工具，定位页面中任意一个 安装 按钮，然后找到代码中的 <code>id=&quot;XXX&quot;</code> 字样，如下图中 <code>id=&quot;frp&quot;</code><img src="https://i.loli.net/2018/08/24/5b7fe2f2b05c2.png" alt="WX20180824-185008@2x"></p><p>修改为 <code>id=&quot;ss&quot;</code> :</p><p><img src="https://i.loli.net/2018/08/24/5b7fe39d84ce1.png" alt="ss"></p><p>然后点安装，成功后会回到 MT 工具箱首页，配置使用即可。</p><p><img src="https://i.loli.net/2018/08/24/5b7fe3f098188.png" alt="finish"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;打开 SSH，安装 Misstar Tools，安装所需插件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Shadowsocks" scheme="https://www.devorz.com/tags/Shadowsocks/"/>
    
      <category term="VPN" scheme="https://www.devorz.com/tags/VPN/"/>
    
      <category term="翻墙" scheme="https://www.devorz.com/tags/%E7%BF%BB%E5%A2%99/"/>
    
      <category term="SS" scheme="https://www.devorz.com/tags/SS/"/>
    
      <category term="SSR" scheme="https://www.devorz.com/tags/SSR/"/>
    
  </entry>
  
  <entry>
    <title>折腾树莓派-初次安装</title>
    <link href="https://www.devorz.com/2017/12/27/Paspbian-On-macOs/"/>
    <id>https://www.devorz.com/2017/12/27/Paspbian-On-macOs/</id>
    <published>2017-12-27T14:09:39.000Z</published>
    <updated>2018-07-13T06:24:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h2><p>  先到<a href="http://www.raspberrypi.org/downloads" target="_blank" rel="noopener">树莓派官网</a>去下载一个系统镜像，推荐下载Raspbian。</p><p>下载完成后得到一个img镜像.<br>计算SHA256验证（大约需要2分钟）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl dgst -sha256 /Users/Jatstar/Downloads/2017-11-29-raspbian-stretch.img</span><br></pre></td></tr></table></figure><p>得到的 SHA256 值与官网给出的一致，文件完整。</p><p>使用<code>df -h</code>命令查看当前已挂载的卷：<br><img src="https://i.loli.net/2017/12/27/5a43ac6bc4eb2.jpg" alt=""></p><p>对比Size和Name可以找到SD卡的分区在系统里对应的设备文件（这里是/dev/disk2s1），如果你有多个分区，可能还会有disk2s2之类的。使用<code>diskutil unmount</code>将这些分区卸载：</p><p><img src="https://i.loli.net/2017/12/27/5a43accb9c059.jpg" alt=""></p><p>通过<code>diskutil list</code>来确认设备：</p><p><img src="https://i.loli.net/2017/12/27/5a43acfba0830.jpg" alt=""></p><p>使用dd命令将系统镜像写入，需要特别特别注意disk后的数字，不能搞错！</p><blockquote><p>说明：/dev/disk1s1是分区，/dev/disk1是块设备，/dev/rdisk1是原始字符设备）</p></blockquote><p><img src="https://i.loli.net/2017/12/27/5a43ad6235195.jpg" alt=""></p><p>用diskutil unmountDisk卸载设备：</p><p><img src="https://i.loli.net/2017/12/27/5a43adc33026a.jpg" alt=""></p><p>现在就可以拔下SD卡，插到树莓派上启动系统了。</p><h2 id="远程登录"><a href="#远程登录" class="headerlink" title="远程登录"></a>远程登录</h2><p>在 SD 卡根目录下执行 <code>touch SSH</code> 创建一个空的SSH文件，安全退出SD 卡，插到树莓派上启动系统，系统会在启动时开启SSH。</p><p><img src="https://i.loli.net/2017/12/28/5a43c92e2efc7.jpg" alt=""></p><p>通过查看路由器管理后台，得到树莓派的内网IP。<br>也可以看到通过连接/断开树莓派时分别执行 <code>arp -a</code>命令推导出树莓派内网IP.</p><p>使用 <code>ssh pi@192.168.31.197</code> 命令登录树莓派。<br>也Termius登录：</p><p><img src="https://i.loli.net/2017/12/28/5a43cb4cdc6e9.jpg" alt=""></p><p>登录密码默认为 <code>raspberry</code> .</p><p>登录成功：</p><p><img src="https://i.loli.net/2017/12/28/5a43cbaae9d29.jpg" alt=""></p><p>执行<code>sudo apt-get install tightvncserver</code>安装VNC Server：</p><p><img src="https://i.loli.net/2017/12/28/5a43cc97348ee.jpg" alt=""></p><p>执行<code>vncserver :1 -geometry 1024x768</code>启动VNC Server：</p><p><img src="https://i.loli.net/2017/12/28/5a43cd1cac9d3.jpg" alt=""></p><p>下载 <a href="https://www.realvnc.com/en/connect/download/viewer/" target="_blank" rel="noopener">VNC viewer</a>,输入树莓派IP以及vncserver端口登录：</p><p><img src="https://i.loli.net/2017/12/28/5a43ceb8a9b2e.jpg" alt=""><br>大功告成。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;系统安装&quot;&gt;&lt;a href=&quot;#系统安装&quot; class=&quot;headerlink&quot; title=&quot;系统安装&quot;&gt;&lt;/a&gt;系统安装&lt;/h2&gt;&lt;p&gt;  先到&lt;a href=&quot;http://www.raspberrypi.org/downloads&quot; target=&quot;_bl
      
    
    </summary>
    
    
      <category term="Paspberry Pi" scheme="https://www.devorz.com/tags/Paspberry-Pi/"/>
    
      <category term="树莓派" scheme="https://www.devorz.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>What&#39;s New in Notifications(WWDC2015-Session 720)</title>
    <link href="https://www.devorz.com/2017/10/12/iOS-Notifications/"/>
    <id>https://www.devorz.com/2017/10/12/iOS-Notifications/</id>
    <published>2017-10-12T15:48:01.000Z</published>
    <updated>2018-07-13T06:24:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Silent-Notifications"><a href="#Silent-Notifications" class="headerlink" title="Silent Notifications"></a>Silent Notifications</h2><p><img src="https://i.loli.net/2017/10/13/59df9511662f4.png" alt="WX20171013-001455@2x"></p><ul><li>Silent (don’t show UI to the user)</li><li>Romote notifications</li><li>Enabled by default(without ask the user for permission)</li><li>The mechanism behind background app refresh(user can go in settings ing and disable them)</li></ul><h2 id="User-Notifications"><a href="#User-Notifications" class="headerlink" title="User Notifications"></a>User Notifications</h2><ul><li>Notify the user</li><li>Require user permission</li></ul><h3 id="Remote-Notifications"><a href="#Remote-Notifications" class="headerlink" title="Remote Notifications"></a>Remote Notifications</h3><ul><li>Silent notification can inside a user notifications</li></ul><h3 id="Local-Notifications"><a href="#Local-Notifications" class="headerlink" title="Local Notifications"></a>Local Notifications</h3><ul><li>Scheduled by your own app(By time or location)</li><li>no server , no internet</li></ul><h2 id="Text-Input-Action-iOS-9"><a href="#Text-Input-Action-iOS-9" class="headerlink" title="Text Input Action (iOS 9)"></a>Text Input Action (iOS 9)</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Registering</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> replyAction = <span class="type">UIMutableUserNotificationAction</span>()</span><br><span class="line">replyAction.title = <span class="string">"Reply"</span></span><br><span class="line">replyAction.identifier = <span class="string">"comment-reply"</span></span><br><span class="line">replyAction.activationMode = .<span class="type">Background</span></span><br><span class="line">replyAction.requiresAuthentication = <span class="literal">false</span></span><br><span class="line">replyAction.behavior = .<span class="type">TextInput</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> category = <span class="type">UIMutableUserNotificationCategory</span>()  category.identifier = <span class="string">"reply"</span> </span><br><span class="line">category.actions = [ replyAction ]</span><br><span class="line"><span class="keyword">let</span> settings = <span class="type">UIUserNotificationSettings</span>(forTypes: [ .<span class="type">Sound</span> , .<span class="type">Alert</span> ],  categories: [ category ])</span><br><span class="line"><span class="type">UIApplication</span>.sharedApplication().registerUserNotificationSettings(settings)</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Receiving</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(application: UIApplication,  handleActionWithIdentifier identifier: String?, </span></span></span><br><span class="line"><span class="function"><span class="params">          forLocalNotification notification: UILocalNotification,</span></span></span><br><span class="line"><span class="function"><span class="params">withResponseInfo responseInfo: [ NSObject : AnyObject ],  completionHandler completionHandler: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="comment">//Handling the response</span></span><br><span class="line">  <span class="keyword">if</span> identifier == <span class="string">"comment-reply"</span>,</span><br><span class="line">     <span class="keyword">let</span> response = responseInfo[<span class="type">UIUserNotificationActionResponseTypedTextKey</span>],</span><br><span class="line">         responseText = response <span class="keyword">as</span>? <span class="type">String</span> &#123;</span><br><span class="line">      viewController.appendText(responseText)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  completionHandler()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Silent-Notifications&quot;&gt;&lt;a href=&quot;#Silent-Notifications&quot; class=&quot;headerlink&quot; title=&quot;Silent Notifications&quot;&gt;&lt;/a&gt;Silent Notifications&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
      <category term="APNs" scheme="https://www.devorz.com/tags/APNs/"/>
    
      <category term="Notification" scheme="https://www.devorz.com/tags/Notification/"/>
    
      <category term="WWDC" scheme="https://www.devorz.com/tags/WWDC/"/>
    
      <category term="Sission 720" scheme="https://www.devorz.com/tags/Sission-720/"/>
    
  </entry>
  
  <entry>
    <title>iOS用户数据安全之--Keychain和Touch ID</title>
    <link href="https://www.devorz.com/2017/09/01/Keychain-and-Touch-ID/"/>
    <id>https://www.devorz.com/2017/09/01/Keychain-and-Touch-ID/</id>
    <published>2017-08-31T16:55:50.000Z</published>
    <updated>2018-07-13T06:24:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文 <a href="https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id" target="_blank" rel="noopener">How To Secure iOS User Data: The Keychain and Touch ID</a><br>使用登录页是一个保护程序中用户数据安全的好方法，你可以使用 iOS 中自带的 Keychain 来确保他们的数据安全。Apple 也提供了另一层保护，那就是 Touch ID 。Touch ID 储存指纹信息在A7以及更新的芯片中的安全区域。<br>  这一起意味着你可以安心的把处理登录信息的任务交给 Keychain 和（或者） Touch ID。<br><a id="more"></a></p><blockquote><p>Touch ID需要真机调试，Keychain可以在模拟器中使用。</p></blockquote><h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><p>请下载这个教程的<a href="https://koenig-media.raywenderlich.com/uploads/2017/04/TouchMeInCD-starter-v1.03-4.zip" target="_blank" rel="noopener">初始项目</a>;</p><p>这是一个基础的记事本应用，使用CoreData来储存用户的笔记。 storyboard上有一个登录页，用户可以填入用户名和密码，剩下的页面也已经彼此连上准备使用。<br>编译运行，可以看到，你的应用看起来是这样的：<br><img src="https://i.loli.net/2017/09/01/59a846c430721.png" alt=""></p><p>现在，点击 Login 按钮轻易的dismisses视图，然后显示笔记列表。你也可以创建一个新的笔记在这个界面。点击 Logout 带你回到登录页。如果应用被切到后台它将立即回到登录页；通过这样的方式保护数据。这是通过设置 info.plist 的 Application does not run in background 为 YES 实现的。<br>在你做任何事之前，你需要修改 Bundle identifier,分配一个适当的 Team 。<br>在 Project Navigator 中选择 TouchMeIn ,然后选择 ToumenIn target 。在 General 一栏中使用自己的域名修改 Bundle Identifier 。使用 reverse-domain-notation 例如  com.raywenderich.TouchMeIn 。<br>然后，从 Team 菜单选择一个 你的开发者账号关联的 team,像这样：<br><img src="https://i.loli.net/2017/09/03/59ac1600e5737.png" alt=""></p><h2 id="Logging-NO-Log-IN"><a href="#Logging-NO-Log-IN" class="headerlink" title="Logging? NO. Log IN."></a>Logging? NO. Log IN.</h2><p>接下来，你将为项目添加验证用户的账号的能力，数据是硬编码的值。</p><p>打开 LoginViewController.swift 然后在 <code>managedObjectContext</code> 下面添加常量：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> usernameKey = <span class="string">"batman"</span></span><br><span class="line"><span class="keyword">let</span> passwordKey = <span class="string">"Hello bruce!"</span></span><br></pre></td></tr></table></figure><p>这是一个简易的硬编码用户名和密码，你将用它来和用户提供的做对比。</p><p>在 <code>loginAction(_:)</code> 下面添加如下方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkLogin</span><span class="params">(username: String, password: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> username == usernameKey &amp;&amp; password == passwordKey</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法拿用户输入的账户和你早已定义的常量做对比。</p><p>然后，使用下列代码替换<code>loginAction(_:)</code>方法的内容：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> checkLogin(username: usernameTextField.text!, password: passwordTextField.text!) &#123;</span><br><span class="line">  performSegue(withIdentifier: <span class="string">"dismissLogin"</span>, sender: <span class="keyword">self</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码调用了 <code>checkLogin(username:password:)</code>, 如果账户正确，将 dismisses 登录页。</p><p>编译运行，输入乎用户名 <code>batman</code> 密码 <code>Hello Bruce!</code> 然后点击 Login 按钮，登录页将如预料中一样 dismiss。</p><p>While this simple approach to authentication seems to work, it’s not terribly secure, as credentials stored as strings can easily be compromised by curious hackers with the right tools and training. As a best practice, passwords should NEVER be stored directly in the app.<br>虽然这种简单的认证方法似乎很有效，但它并不是非常安全，因为存储在字符串中的凭证很容易受到好奇的黑客使用合适的工具尝试攻击。作为最佳实践，<em>密码**</em>绝不应该<em>**直接存储在应用程序中</em>。</p><p>接下来一步是添加 Keychain 封装类到你的应用。</p><h2 id="Rapper-No-Wrapper"><a href="#Rapper-No-Wrapper" class="headerlink" title="Rapper? No. Wrapper."></a>Rapper? No. Wrapper.</h2><p>在初始项目中，你可以找到你已经下载的 KeychainPasswordItem.swift 文件，这个类来自 Apple’s sample code 中的 <a href="https://developer.apple.com/library/content/samplecode/GenericKeychain/Introduction/Intro.html#//apple_ref/doc/uid/DTS40007797-Intro-DontLinkElementID_2" target="_blank" rel="noopener"><code>GenericKeychain</code></a>。</p><p>在资源文件夹, 把 KeychainPasswordItem.swift 拖进项目，像这样：<br><img src="https://i.loli.net/2017/09/03/59ac216bd425e.png" alt=""></p><p>在提示中，确认 <code>Copy items if needed</code> 和 <code>TouchMeIn</code> target 是选中的：<br><img src="https://i.loli.net/2017/09/03/59ac21dd5e550.png" alt=""></p><p>编译运行确认没有错误，很好，现在你可以在你的应用中使用 Keychain 了。</p><h2 id="Keychain-Meet-Password-Password-Meet-Keychain"><a href="#Keychain-Meet-Password-Password-Meet-Keychain" class="headerlink" title="Keychain, Meet Password. Password, Meet Keychain"></a>Keychain, Meet Password. Password, Meet Keychain</h2><p>使用 Keychain ，首先你要储存一个用户名密码，然后呢，比对用户提供的账号和 Keychain 的是否相等。</p><p>你需要跟踪用户是否已经创建了账号以便你将登录按钮上的文本从 “Create”改为 “Login” ,你也可以储存用户默认的用户名，这样不用每次都从 Keychain 中访问。</p><p>Keychain 需要一些必要的配置来正确的储存你的应用信息。 你需要配置一个 serviceName 和 一个 可选的 accessGrop 。 你将添加一个结构体来储存他们的值。</p><p>打开 LoginViewController.swift ，在文件的顶端，imports 的下面，加上这个结构体：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Keychain Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KeychainConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">let</span> serviceName = <span class="string">"TouchMeIn"</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">let</span> accessGroup: <span class="type">String</span>? = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后删除下面的两行：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> usernameKey = <span class="string">"batman"</span></span><br><span class="line"><span class="keyword">let</span> passwordKey = <span class="string">"Hello Bruce!"</span></span><br></pre></td></tr></table></figure><p>在这个地方加入下面的代码： </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> passwordItems: [<span class="type">KeychainPasswordItem</span>] = []</span><br><span class="line"><span class="keyword">let</span> createLoginButtonTag = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> loginButtonTag = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> loginButton: <span class="type">UIButton</span>!</span><br></pre></td></tr></table></figure><p>passwordItems 一个装 KeychainPasswordItem 类型的数组。接下来的两个常量用来标记这个登录按钮是用来创建账户还是登录；loginButton 的 outlet 将用来根据状态更新相应的标题。</p><p>打开 Main.storyboard 选择 Login View Controller Scene，按住 Ctrl 键同时从 Login View Controller拖一根线到登录按钮，像下面这样：<br><img src="https://i.loli.net/2017/09/04/59ad78234e254.png" alt=""></p><p>在弹出的列表中选择 loginButton ：</p><p><img src="https://i.loli.net/2017/09/05/59aec4d08ae2e.png" alt=""></p><p>接下来当按钮被点击时你需要处理以下两种情况：如果用户没有创建账号，按钮上的文本将显示 “Create”,否则按钮将显示 “Login” 。你还需要对比输入的账户和 keychain 中保存的。</p><p>打开 LoginViewController.swift ，用以下代码覆盖 loginAction(_:)  中的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">loginAction</span><span class="params">(<span class="number">_</span> sender: AnyObject)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="comment">// Check that text has been entered into both the username and password fields.</span></span><br><span class="line">    <span class="keyword">guard</span></span><br><span class="line">      <span class="keyword">let</span> newAccountName = usernameTextField.text,</span><br><span class="line">      <span class="keyword">let</span> newPassword = passwordTextField.text,</span><br><span class="line">      !newAccountName.isEmpty &amp;&amp;</span><br><span class="line">      !newPassword.isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> alertView = <span class="type">UIAlertController</span>(title: <span class="string">"Login Problem"</span>,</span><br><span class="line">                                          message: <span class="string">"Wrong username or password."</span>,</span><br><span class="line">                                          preferredStyle:. alert)</span><br><span class="line">        <span class="keyword">let</span> okAction = <span class="type">UIAlertAction</span>(title: <span class="string">"Foiled Again!"</span>, style: .<span class="keyword">default</span>, handler: <span class="literal">nil</span>)</span><br><span class="line">        alertView.addAction(okAction)</span><br><span class="line">        present(alertView, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    usernameTextField.resignFirstResponder()</span><br><span class="line">    passwordTextField.resignFirstResponder()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">if</span> sender.tag == createLoginButtonTag &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 4</span></span><br><span class="line">      <span class="keyword">let</span> hasLoginKey = <span class="type">UserDefaults</span>.standard.bool(forKey: <span class="string">"hasLoginKey"</span>)</span><br><span class="line">      <span class="keyword">if</span> !hasLoginKey &#123;</span><br><span class="line">        <span class="type">UserDefaults</span>.standard.setValue(usernameTextField.text, forKey: <span class="string">"username"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 5</span></span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// This is a new account, create a new keychain item with the account name.</span></span><br><span class="line">        <span class="keyword">let</span> passwordItem = <span class="type">KeychainPasswordItem</span>(service: <span class="type">KeychainConfiguration</span>.serviceName,</span><br><span class="line">                                                account: newAccountName,</span><br><span class="line">                                                accessGroup: <span class="type">KeychainConfiguration</span>.accessGroup)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Save the password for the new item.</span></span><br><span class="line">        <span class="keyword">try</span> passwordItem.savePassword(newPassword)</span><br><span class="line">      &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"Error updating keychain - \(error)"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 6</span></span><br><span class="line">      <span class="type">UserDefaults</span>.standard.<span class="keyword">set</span>(<span class="literal">true</span>, forKey: <span class="string">"hasLoginKey"</span>)</span><br><span class="line">      loginButton.tag = loginButtonTag</span><br><span class="line">      </span><br><span class="line">      performSegue(withIdentifier: <span class="string">"dismissLogin"</span>, sender: <span class="keyword">self</span>)</span><br><span class="line">      </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> sender.tag == loginButtonTag &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 7</span></span><br><span class="line">      <span class="keyword">if</span> checkLogin(username: usernameTextField.text!, password: passwordTextField.text!) &#123;</span><br><span class="line">        performSegue(withIdentifier: <span class="string">"dismissLogin"</span>, sender: <span class="keyword">self</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 8</span></span><br><span class="line">        <span class="keyword">let</span> alertView = <span class="type">UIAlertController</span>(title: <span class="string">"Login Problem"</span>,</span><br><span class="line">                                          message: <span class="string">"Wrong username or password."</span>,</span><br><span class="line">                                          preferredStyle: .alert)</span><br><span class="line">        <span class="keyword">let</span> okAction = <span class="type">UIAlertAction</span>(title: <span class="string">"Foiled Again!"</span>, style: .<span class="keyword">default</span>)</span><br><span class="line">        alertView.addAction(okAction)</span><br><span class="line">        present(alertView, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>以下是代码的说明：</p><ol><li>如果用户名或者密码中有一项为空，弹出警告，并且 return 。</li><li>Dismiss 键盘，如果它可见的话。</li><li>如果登录按钮的 <code>tag</code> 是 <code>createLoginButtonTag</code>，然后开始创建一个新账户。</li><li>接下来 ，从 <code>UserDefaults</code> 读取 <code>hasLoginKey</code> 的值，它标记了 Keychain 中是否有密码保存。 如果 <code>username</code> 的输入框不用空且 <code>hasLoginKey</code> 标记了没有账户保存，那接下来你要保存 <code>username</code> 到 <code>UserDefaults</code> 。</li><li>使用 <code>serviceName</code> ，<code>newAccountName</code>（username）创建一个 <code>KeychainPasswordItem</code>。使用 Swift 的错误处理，如过遇到问题将 <code>catch</code> 掉。</li><li>然后设置 <code>UserDefaults</code> 中的 <code>hasLoginKey</code> 为 <code>true</code> 来标记密码已保存。设置登录按钮的 <code>tag</code> 为 <code>loginButtonTag</code> 来改变按钮上的文本，它将在用户下次运行应用的时候提示用户登录，而不是创建账户。 最后 dismiss loginView。</li><li>如果用户想登陆 （标记为 <code>loginButtonTag</code>），你可以调用 <code>checkLogin</code> 来验证用户提供的账户，如果正确，dismiss 登录页。</li><li>如果账户验证不通过，弹窗通知用户。</li></ol><p>接下来使用 下列代码替换 <code>checkLogin(username:password:)</code> 方法的实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkLogin</span><span class="params">(username: String, password: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">guard</span> username == <span class="type">UserDefaults</span>.standard.value(forKey: <span class="string">"username"</span>) <span class="keyword">as</span>? <span class="type">String</span> <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> passwordItem = <span class="type">KeychainPasswordItem</span>(service: <span class="type">KeychainConfiguration</span>.serviceName,</span><br><span class="line">                                              account: username,</span><br><span class="line">                                              accessGroup: <span class="type">KeychainConfiguration</span>.accessGroup)</span><br><span class="line">      <span class="keyword">let</span> keychainPassword = <span class="keyword">try</span> passwordItem.readPassword()</span><br><span class="line">      <span class="keyword">return</span> password == keychainPassword</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="built_in">fatalError</span>(<span class="string">"Error reading password from keychain - \(error)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>对比输入的用户名和 <code>UserDefaults</code> 存入的，对比密码和 Keychain 存入的。</p><p>现在你需要根据 <code>hasLoginKey</code> 的状态给按钮设置适当的文本和tag。</p><p>在 <code>viewDidLoad()</code> 中，调用 <code>super</code> 的下面加入：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">let</span> hasLogin = <span class="type">UserDefaults</span>.standard.bool(forKey: <span class="string">"hasLoginKey"</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">if</span> hasLogin &#123;</span><br><span class="line">    loginButton.setTitle(<span class="string">"Login"</span>, <span class="keyword">for</span>: .normal)</span><br><span class="line">    loginButton.tag = loginButtonTag</span><br><span class="line">    createInfoLabel.isHidden = <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    loginButton.setTitle(<span class="string">"Create"</span>, <span class="keyword">for</span>: .normal)</span><br><span class="line">    loginButton.tag = createLoginButtonTag</span><br><span class="line">    createInfoLabel.isHidden = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> storedUsername = <span class="type">UserDefaults</span>.standard.value(forKey: <span class="string">"username"</span>) <span class="keyword">as</span>? <span class="type">String</span> &#123;</span><br><span class="line">    usernameTextField.text = storedUsername</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>序号对应的注释：</p><ol><li>你首先要检查 <code>hasLoginKey</code> 来确认是否已有账户。</li><li>如果有，把按钮文本改为 Login，tag 改为 <code>loginButtonTag</code>，还要隐藏包含来“Start by creating a username and password“提示的 <code>createInfoLabel</code>。如果你没有一个已存的账户，设置按钮的文本为 Create 然后显示 createInfoLabel 给用户。</li><li>最后将 <code>UserDefaults</code> 中储存的用户名回填回输入框，给用户提供一点方便。</li></ol><p>编译运行，输入你想要的用户名密码， 然后点击 <code>Create</code>。</p><p>现在点击 Logout 然后使用相同的用户名和密码进行登录，你将看到笔记列表。</p><p>点击 Logout ，然后再次尝试登录，这次使用不同的密码然后点击登陆，你将看到下面的提示：<br><img src="https://i.loli.net/2017/09/06/59aed19446dd8.png" alt=""></p><p>恭喜，你完成了使用 Keychain 做验证，下一步 Touch ID。</p><h2 id="Touching-You-Touching-Me"><a href="#Touching-You-Touching-Me" class="headerlink" title="Touching You, Touching Me"></a>Touching You, Touching Me</h2><blockquote><p>需设置支持</p></blockquote><p>在这一节，你讲添加 Touch ID 到你的项目配合 Keychain 。 Keychain并不是 Touch ID 正常工作的必要条件，它是一个好的解决方案，当Touch ID失败时或者设备不支持时。</p><p>打开 <code>Images.xcassets</code>。<br>打开 <code>Resources</code> 文件夹，找到 <code>Touch-icon-lg.png</code>,<a href="mailto:``Touch-icon-lg@2x.png" target="_blank" rel="noopener">``Touch-icon-lg@2x.png</a><code>和</code><a href="mailto:Touch-icon-lg@3x.png" target="_blank" rel="noopener">Touch-icon-lg@3x.png</a><code></code> 选中，然后把这三项全部拖入 Images.xcassets 。Xcode 知道他们是相同的图片，只是分辨率不同：<br><img src="https://i.loli.net/2017/09/06/59aedbdb19433.png" alt=""></p><p>打开 <code>Main.storyboard</code> ，从 <code>Object Library</code> 拖动一个 <code>Button</code> 到 <code>Login View Controller Scene</code> ，贴在 <code>Create Info Label</code> 底部,加到 <code>Stack View</code> 中。你可以打开 <code>Document Outline</code> ,打开三角形，确认 <code>Button</code> 在 <code>Stack View</code> 中。它看起来应该是这样的：</p><p><img src="https://ooo.0o0.ooo/2017/09/06/59b00f24c21db.png" alt=""></p><p>如果你需要回顾 Stack Views的知识，可以查阅 Jawwad Ahmad 写的 <a href="https://www.raywenderlich.com/160646/uistackview-tutorial-introducing-stack-views-2" target="_blank" rel="noopener">UIStackView Tutorial: Introducing Stack Views</a></p><p>使用 Attributes Inspector 调整按钮的属性，如下：</p><ul><li>设置 Type 为 Custom 。</li><li>Title 清空。</li><li>设置 Image 为 Touch-icon-lg 。</li></ul><p>完成之后，按钮的属性应该是这样的：<br><img src="https://ooo.0o0.ooo/2017/09/06/59b010ef8b899.png" alt=""></p><p>在确保新加的按钮为选中的状态下，点击 storyboard 底部的 layout bar 上的 Add New Constraints ，设置约束如下：<br><img src="https://ooo.0o0.ooo/2017/09/06/59b011ba96833.png" alt=""></p><ul><li><code>Width</code> 为 66。</li><li><code>Height</code> 为 67。</li></ul><p>界面现在看起来是这样的：<br><img src="https://ooo.0o0.ooo/2017/09/06/59b012106571a.png" alt=""></p><p>仍然是在  Main.storyboard 上 ，打开 Assistant Editor，确保可见。</p><p>现在，按住 Ctrl 键 ，把按钮加到 LoginViewController.swift 中 ，接在其他属性的下面，像这样：</p><p><img src="https://ooo.0o0.ooo/2017/09/06/59b01309334ca.png" alt=""></p><p>在弹框中的 Name项中填入 <code>touchIDButton</code> ，点击 Connect：</p><p><img src="https://ooo.0o0.ooo/2017/09/06/59b013a21b0f9.png" alt=""></p><p>这样创建了一个 outlet ，在设备没有 Touch ID 可用时隐藏按钮。<br>现在你需要给按钮添加事件。<br>按住 Ctrl 拖动相同的按钮到 LoginViewController.swift 中 checkLogin(username:password:):方法的顶部： </p><p><img src="https://ooo.0o0.ooo/2017/09/06/59b014771a2ef.png" alt=""></p><p>在弹窗中，把 Connection 项改为 Action ，设置 Name 为 touchIDLoginAction ,设置 Type 为 UIbutton ,然后点击 Connect:</p><p><img src="https://ooo.0o0.ooo/2017/09/06/59b0156a99fff.png" alt=""></p><p>编译运行确认无误，此时可以在模拟器中运行，因为还没有添加Touch ID 的支持。现在将要开始了。</p><h2 id="Adding-Local-Authentication"><a href="#Adding-Local-Authentication" class="headerlink" title="Adding Local Authentication"></a>Adding Local Authentication</h2><p> 实现 Touch ID 就像 引入  Local Authentication 库和调用几个方法一样简单。<br>  Local Authentication 文档中这样说到：</p><blockquote><p>“The Local Authentication framework provides facilities for requesting authentication from users with specified security policies.”<br>   Local Authentication 库通过指定的安全策略为用户提供方便的请求认证。</p></blockquote><p>本例中指定的策略将是你的用户的手指～</p><p>在 Xcode 的 Project Navigator 鼠标右键点击 TouchMeIn 组文件夹，点击 New File… ，选择 iOS 下的  Swift File ，点击下一步，确认 <code>TouchMeIn</code> target为选中，保存为 TouchIDAuthentication.swift,点击 <code>Create</code>。</p><p>打开 TouchIDAuthentication.swift， 在 引入 Foundation 的下面加加入：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> LocalAuthentication</span><br></pre></td></tr></table></figure><p>创建一个新的类:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TouchIDAuth</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在你需要引入  <code>LAcontext</code> 类。<br>在大括号中加入：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> context = <span class="type">LAContext</span>()</span><br></pre></td></tr></table></figure><p>上文引入一个身份验证上下文，它是 Local Authentication 中的主角，现在需要一个方法来看看用户设备或者模拟器中的 Touch ID是否可用。</p><p>创建下面的方法，返回一个 Bool 支持 Touch ID 的话。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canEvaluatePolicy</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开 LoginViewController.swift 。</p><p>创建一个属性引入你刚刚创建的类。</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> touchMe = <span class="type">TouchIDAuth</span>()</span><br></pre></td></tr></table></figure><p> 在 <code>viewDidLoad()</code> 中加入:</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touchIDButton.isHidden = !touchMe.canEvaluatePolicy()</span><br></pre></td></tr></table></figure><p> 这里使用了 <code>canEvaluatePolicy(_:error:)</code> 来检查设备是否可以实现 Touch ID 认证，如果可以，显示Touch ID按钮，否则就隐藏。</p><p> 编译运行在模拟器上，你会看到 Touch ID 的 logo 是隐藏的。现在你再编译在一台可以 Touch ID 的真机上，会发现，按钮时显示的。</p><h2 id="Putting-Touch-ID-to-Work"><a href="#Putting-Touch-ID-to-Work" class="headerlink" title="Putting Touch ID to Work"></a>Putting Touch ID to Work</h2><p>回到 TouchIDAuthentication.swift 添加一个验证用户的方法，在 TouchIDAuth 类的底部，创建以下方法 ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">authenticateUser</span><span class="params">(completion: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123; <span class="comment">// 1</span></span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">guard</span> canEvaluatePolicy() <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics,</span><br><span class="line">    localizedReason: <span class="string">"Logging in with Touch ID"</span>) &#123; (success, evaluateError) <span class="keyword">in</span></span><br><span class="line">      <span class="comment">// 4</span></span><br><span class="line">      <span class="keyword">if</span> success &#123;</span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">          <span class="comment">// User authenticated successfully, take appropriate action</span></span><br><span class="line">          completion()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> deal with LAError cases</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是说明：</p><ol><li><code>authenticateUser(completion:)</code> 的结果将通过闭包返回给 <code>LoginViewController</code>。</li><li>使用  <code>canEvaluatePolicy()</code> 检车设备是否具备 Touch ID 的能力。</li><li>如果设备支持 Touch ID ，你可以使用 <code>evaluatePolicy(_:localizedReason:reply:)</code> 开始验证，也就是提示用户Touch ID验证，当执行完成这个方法回调 block 。 </li><li>在回调的 block 中，先处理成功的情况。 默认情况下，验证发生在 private 线程，你需要回到住现在来更新UI。 如果验证通过，你将 dismisses 登陆页。</li></ol><p>一会儿来处理错误。</p><p>选择 LoginViewController.swift 滑到 <code>touchIDLoginAction(_:)</code> 。<br>添加代码，使它变成这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">touchIDLoginAction</span><span class="params">(<span class="number">_</span> sender: UIButton)</span></span> &#123;    </span><br><span class="line">    touchMe.authenticateUser() &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">self</span>?.performSegue(withIdentifier: <span class="string">"dismissLogin"</span>, sender: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果用户验证通过，就可以 dismiss 登陆页了。</p><p>你可以在你的设备上编译运行，但是等等，如果你没有设置 Touch ID ,或者使用的错误的手指？让我们来处理这个问题。</p><p>继续编译运行，看看是否一切正常。</p><h2 id="Dealing-with-Errors"><a href="#Dealing-with-Errors" class="headerlink" title="Dealing with Errors"></a>Dealing with Errors</h2><p>Local Authentication  的重要一步是 响应错误。所以库中引入了一个 LAError 类型。也可能是第二步 <code>canEvaluatePolicy</code> 得到的错误。 你可以弹出警告展示错误信息给用户。你需要从 TouchIDAuth 传递一个消息到 LoginViewController 。幸运的是你有一个完成的回调，你可以使用它传递一个可选的信息。<br>回到 TouchIDAuthentication.swift ，更新  authenticateUser 方法。<br>插入一个可选的 message ，用在得到错误信息时，传递出去。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">authenticateUser</span><span class="params">(completion: @escaping <span class="params">(String?)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br></pre></td></tr></table></figure><p>找到 <code>//TODO:</code> 替换 ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">            <span class="keyword">let</span> message: <span class="type">String</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2</span></span><br><span class="line">            <span class="keyword">switch</span> evaluateError &#123;</span><br><span class="line">            <span class="comment">// 3</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">LAError</span>.authenticationFailed?:</span><br><span class="line">              message = <span class="string">"There was a problem verifying your identity."</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">LAError</span>.userCancel?:</span><br><span class="line">              message = <span class="string">"You pressed cancel."</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">LAError</span>.userFallback?:</span><br><span class="line">              message = <span class="string">"You pressed password."</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">              message = <span class="string">"Touch ID may not be configured"</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4</span></span><br><span class="line">            completion(message)</span><br></pre></td></tr></table></figure><p>说明 ：</p><ol><li>定义一个 string 来接受消息。</li><li>使用 switch 语句为每种错误的情况设置合适的错误提示信息。</li><li>如果任务失败，你显示一个通用的警告框，练习中，你需要对特定的错误代码进行处理，包括：<ul><li><code>LAError.touchIDNotAvailable</code> touch ID 不可用。</li><li><code>LAError.passcodeNotSet</code> 没有启动 Touch ID必要的 passcode。</li><li><code>LAError.touchIDNotEnrolled</code> 没有指纹存储。</li></ul></li><li>在 completion 闭包中传递消息。</li></ol><p>iOS 会在相关的警告中响应 <code>LAError.passcodeNotSet</code> 和 <code>LAError.touchIDNotEnrolled</code>。  </p><p>还有一个错误要处理。<code>guard</code> 中，<code>else</code> 只有return.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">completion(<span class="string">"Touch ID not available"</span>)</span><br></pre></td></tr></table></figure><p>最后更新一个下成功的情况，这个需要返回 nil, 代表没有错误。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">completion(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>完成后，方法应该是这样的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">authenticateUser</span><span class="params">(completion: @escaping <span class="params">(String?)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">guard</span> canEvaluatePolicy() <span class="keyword">else</span> &#123;</span><br><span class="line">    completion(<span class="string">"Touch ID not available"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics,</span><br><span class="line">    localizedReason: <span class="string">"Logging in with Touch ID"</span>) &#123; (success, evaluateError) <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">if</span> success &#123;</span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">          completion(<span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            </span><br><span class="line">        <span class="keyword">let</span> message: <span class="type">String</span></span><br><span class="line">                            </span><br><span class="line">        <span class="keyword">switch</span> evaluateError &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">LAError</span>.authenticationFailed?:</span><br><span class="line">          message = <span class="string">"There was a problem verifying your identity."</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">LAError</span>.userCancel?:</span><br><span class="line">          message = <span class="string">"You pressed cancel."</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">LAError</span>.userFallback?:</span><br><span class="line">          message = <span class="string">"You pressed password."</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          message = <span class="string">"Touch ID may not be configured"</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        completion(message)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择 LoginViewController.swift ，更新  <code>touchIDLoginAction(_:)</code> 成这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">touchIDLoginAction</span><span class="params">(<span class="number">_</span> sender: UIButton)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    touchMe.authenticateUser() &#123; message <span class="keyword">in</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 2</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> message = message &#123;</span><br><span class="line">        <span class="comment">// if the completion is not nil show an alert</span></span><br><span class="line">        <span class="keyword">let</span> alertView = <span class="type">UIAlertController</span>(title: <span class="string">"Error"</span>,</span><br><span class="line">                                          message: message,</span><br><span class="line">                                          preferredStyle: .alert)</span><br><span class="line">        <span class="keyword">let</span> okAction = <span class="type">UIAlertAction</span>(title: <span class="string">"Darn!"</span>, style: .<span class="keyword">default</span>)</span><br><span class="line">        alertView.addAction(okAction)</span><br><span class="line">        <span class="keyword">self</span>.present(alertView, animated: <span class="literal">true</span>)</span><br><span class="line">        </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">self</span>.performSegue(withIdentifier: <span class="string">"dismissLogin"</span>, sender: <span class="keyword">self</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>我们添加一个尾随闭包（trailing closure）来传递可选消息，如果 Touch ID 正常工作， 没有消息。</li><li>使用 <code>if let</code> 展开错误消息，显示警告。</li><li>不用修改，如果没有错误消息，你可以 dismiss 登陆页。</li></ol><p>编译运行在一个可以指纹识别的设备上，试一下使用 Touch ID 登陆。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文 &lt;a href=&quot;https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;How To Secure iOS User Data: The Keychain and Touch ID&lt;/a&gt;&lt;br&gt;使用登录页是一个保护程序中用户数据安全的好方法，你可以使用 iOS 中自带的 Keychain 来确保他们的数据安全。Apple 也提供了另一层保护，那就是 Touch ID 。Touch ID 储存指纹信息在A7以及更新的芯片中的安全区域。&lt;br&gt;  这一起意味着你可以安心的把处理登录信息的任务交给 Keychain 和（或者） Touch ID。&lt;br&gt;
    
    </summary>
    
    
      <category term="Touch ID" scheme="https://www.devorz.com/tags/Touch-ID/"/>
    
      <category term="Keychain" scheme="https://www.devorz.com/tags/Keychain/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发资料整理</title>
    <link href="https://www.devorz.com/2017/08/11/iOS-Advance/"/>
    <id>https://www.devorz.com/2017/08/11/iOS-Advance/</id>
    <published>2017-08-10T16:45:43.000Z</published>
    <updated>2018-07-13T06:24:13.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="值得关注的网站"><a href="#值得关注的网站" class="headerlink" title="值得关注的网站"></a>值得关注的网站</h2><ul><li><p><a href="https://www.objc.io" target="_blank" rel="noopener">objc</a>//<a href="https://www.objccn.io" target="_blank" rel="noopener">objc中国</a></p></li><li><p><a href="http://nshipster.com" target="_blank" rel="noopener">NSHipster</a>//<a href="http://nshipster.cn" target="_blank" rel="noopener">NSHipster中文版</a></p></li><li><p><a href="https://www.raywenderlich.com" target="_blank" rel="noopener">Raywenderlich</a>;</p></li><li><p><a href="https://github.com/trending" target="_blank" rel="noopener">Github Trending</a></p></li><li><p><a href="http://stackoverflow.com/" target="_blank" rel="noopener">Stack Overflow</a></p></li><li><p><a href="https://developer.apple.com/library/content/navigation/" target="_blank" rel="noopener">Guides and Sample Code</a></p></li></ul><h2 id="书单"><a href="#书单" class="headerlink" title="书单"></a>书单</h2><ul><li><p>《编写高质量iOS与OS X代码的52个有效方法 》(Effective Objective-C 2.0)</p></li><li><p>《iOS与OS X多线程和内存管理》(Pro Multithreading and Memory Management for iOS and OS X)</p></li></ul><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li><p><a href="https://kapeli.com/dash" target="_blank" rel="noopener">Dash</a></p></li><li><p><a href="https://www.alfredapp.com" target="_blank" rel="noopener">Alfred</a></p></li><li><p><a href="https://revealapp.com" target="_blank" rel="noopener">Reveal</a></p></li><li><p><a href="https://itunes.apple.com/cn/app/mweb-%E4%B8%93%E4%B8%9A%E7%9A%84markdown%E5%86%99%E4%BD%9C-%E8%AE%B0%E7%AC%94%E8%AE%B0-%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E7%94%9F%E6%88%90%E8%BD%AF%E4%BB%B6/id954188948?mt=12" target="_blank" rel="noopener">MWeb</a></p></li><li><p><a href="https://www.charlesproxy.com" target="_blank" rel="noopener">Charles</a></p></li><li><p><a href="https://www.sourcetreeapp.com" target="_blank" rel="noopener">SourceTree</a></p></li><li><p><a href="https://iterm2.com" target="_blank" rel="noopener">iTerm2</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;值得关注的网站&quot;&gt;&lt;a href=&quot;#值得关注的网站&quot; class=&quot;headerlink&quot; title=&quot;值得关注的网站&quot;&gt;&lt;/a&gt;值得关注的网站&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.ob
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://www.devorz.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>macOS下使用MAMP配置多站点PHP集成开发环境</title>
    <link href="https://www.devorz.com/2017/07/07/Mac-PHP-MAMP/"/>
    <id>https://www.devorz.com/2017/07/07/Mac-PHP-MAMP/</id>
    <published>2017-07-06T16:07:50.000Z</published>
    <updated>2018-07-13T06:24:13.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>在客户端业务稳定需求变少，Server端极度缺人的背景下，被发配来写一手世界上最好的语言了。</p></blockquote><h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><p>macOS想要配置集成PHP开发环境无非那么几种选择：</p><ul><li>使用系统自带的 <code>Apache</code> ，升级系统自带的PHP版本,安装MySQL.</li><li>虚拟机</li><li>homestead（实际也是虚拟机）</li><li>Docker</li><li>MAMP或者 XAMPP</li></ul><p>作为一只萌新，为了减少繁琐的流程，尽早的享受编（tou）程（lan）的乐趣，自然而然的选了MAMP。</p><p>说一下不使用其他几种方式的原因：</p><ul><li>使用自带的会随着macOS系统的升级，环境可能被覆盖。</li><li>虚拟机每次开启服务太繁琐，而且性能没优势。</li><li>XAMPP Retina屏下字体发虚，不能忍。</li><li>Docker 优雅而且能很好的解决开发的环境一致性问题，而且性能也可观。没有使用它的原因是 没有现成的Dockerfile文件且懒得找资料。</li></ul><p>MAMP的安装包包含了MAMP和MAMP PRO，MAMP免费但相对简陋， PRO更为强大，可以很轻松的实现多站点配置,但是收费39.9刀，试用15天免费。<br>15天后，厚着脸皮用改时间大法用了一阵子之后，最终卸载了MAMP PRO。这篇文章主要就是记录卸载了MAMP PRO之后如何用简陋的MAMP配置多站点以及安装所需的PHP扩展。</p><h2 id="MAMP"><a href="#MAMP" class="headerlink" title="MAMP"></a>MAMP</h2><h3 id="Apache-配置"><a href="#Apache-配置" class="headerlink" title="Apache 配置"></a>Apache 配置</h3><p>进入 <code>Applications/MAMP/conf/apache/</code>下打开 <code>httpd.conf</code> 文件。<br>搜索 <code>Include /Applications/MAMP/conf/apache/extra/httpd-vhosts.conf</code>,去掉前面的注释，是虚拟主机文件生效。<br>用文本编辑器打开<code>extra</code> 文件夹下的 <code>httpd-vhosts.conf</code>。<br>写入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Listen 81</span><br><span class="line">Listen 82</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">VirtualHost</span> *<span class="attr">:81</span>&gt;</span></span><br><span class="line">    DocumentRoot "/Users/Jat/Desktop/PHPDev/Test1"</span><br><span class="line">#    ServerName test.com</span><br><span class="line">#   ServerAlias test.com</span><br><span class="line">    <span class="tag">&lt;<span class="name">Directory</span> /&gt;</span></span><br><span class="line">        Options Indexes FollowSymLinks   </span><br><span class="line">        AllowOverride All</span><br><span class="line">        Order deny,allow</span><br><span class="line">        Allow from all</span><br><span class="line">    <span class="tag">&lt;/<span class="name">Directory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">VirtualHost</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">VirtualHost</span> *<span class="attr">:82</span>&gt;</span></span><br><span class="line">    DocumentRoot "/Users/Jat/Desktop/PHPDev/Test2"</span><br><span class="line">#    ServerName test.com</span><br><span class="line">#   ServerAlias test.com</span><br><span class="line">    <span class="tag">&lt;<span class="name">Directory</span> /&gt;</span></span><br><span class="line">        Options Indexes FollowSymLinks   </span><br><span class="line">        AllowOverride All</span><br><span class="line">        Order deny,allow</span><br><span class="line">        Allow from all</span><br><span class="line">    <span class="tag">&lt;/<span class="name">Directory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">VirtualHost</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>VirtualHost</code> 后接Host地址，<code>*</code>为通配符。<br><code>DocumentRoot</code>为站点根目录。<br>监听的端口需要使用<code>Listen</code>指明。</p><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p><code>Preference</code>-&gt; <code>Ports</code>-&gt; <code>MySQL Port</code> 改为 3306。</p><h3 id="Memcache扩展"><a href="#Memcache扩展" class="headerlink" title="Memcache扩展"></a>Memcache扩展</h3><p>首先你需要编译好所需扩展的<code>.so</code>文件。<br>这里我在<a href="https://github.com/majksner/php-memcached-mamp" target="_blank" rel="noopener">Github</a>上找到了编译好的<code>.so</code>文件.（懒出花样。</p><ul><li>拷贝到 <code>/Applications/MAMP/bin/php/phpX.x.x/lib/php/extensions/no-debug-non-zts-200xxxxx</code>( <code>X.x.x</code>代表你使用的PHP版本）。 </li><li>打开 <code>/Applications/MAMP/bin/php/phpX.x.x/conf/php.ini</code></li><li>在 <code>php.ini</code>中加上 <code>extension=memcached.so</code>。</li><li>重启MAMP.</li></ul><h3 id="Memcache依赖"><a href="#Memcache依赖" class="headerlink" title="Memcache依赖"></a>Memcache依赖</h3><ul><li><code>$ brew install memcached</code></li><li><code>$ brew install libmemcached</code></li><li><code>$ brew services start memcached</code> //登陆时启动依赖。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;在客户端业务稳定需求变少，Server端极度缺人的背景下，被发配来写一手世界上最好的语言了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Getting-Started&quot;&gt;&lt;a href=&quot;#Gettin
      
    
    </summary>
    
    
      <category term="PHP" scheme="https://www.devorz.com/tags/PHP/"/>
    
      <category term="MAMP" scheme="https://www.devorz.com/tags/MAMP/"/>
    
      <category term="Memcache" scheme="https://www.devorz.com/tags/Memcache/"/>
    
  </entry>
  
  <entry>
    <title>What&#39;s New in Swift4?</title>
    <link href="https://www.devorz.com/2017/06/19/What-s-New-in-Swift4/"/>
    <id>https://www.devorz.com/2017/06/19/What-s-New-in-Swift4/</id>
    <published>2017-06-18T17:17:04.000Z</published>
    <updated>2018-07-13T06:24:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自<a href="https://www.raywenderlich.com" target="_blank" rel="noopener">Raywenderlich</a>的文章：<a href="https://www.raywenderlich.com/163857/whats-new-swift-4#" target="_blank" rel="noopener">What’s New in Swift 4?</a><br>Swift 4 是Swift下一个大版本更新，预计在2017年秋推出Beta版。其重点在与Swift3的兼容性和ABI稳定性。<br>本文重点介绍一些这个版本中显著影响你代码的变化。好了，让我们开始吧。<br><a id="more"></a></p><h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><p>Swift 4包含在Xcode 9。你可以从苹果的<a href="https://developer.apple.com/download/" target="_blank" rel="noopener">developer portal</a>下载最新的Xcode9(需要一个有效的开发者账号)。每个Beta版的Xcode 都会捆绑最新的Swift 4 快照。</p><p>在你阅读时，你会注意到<code>[SE-xxxx]</code>格式的链接，这些链接将带你进去相关的<code>Swift Evolution</code>提案。如果你想获得很多和主题相关的信息，请务必点开它们。</p><p>我推荐在<code>Playground</code>中尝试Swift 4 的新特性和更新，这有助于在脑海中巩固知识，并使你深入每个主题。把玩这些例子，并尝试扩展／打断他们。玩得开心。</p><blockquote><p>注：这篇文件将在为每个Bate版的Xcode更新，如果你使用的是不同的Swift快照，这些代码不保证可以运行。</p></blockquote><h2 id="Migrating-to-Swift-4"><a href="#Migrating-to-Swift-4" class="headerlink" title="Migrating to Swift 4"></a>Migrating to Swift 4</h2><p>从Swift 3到 4 的迁移比 Swift 2.2 到 3 少了很多麻烦，一般来说，绝大多数的改变都是附加的，并不需要大量的人为修改。因此，Swift 迁移工具为你处理多数的改变。<br>Xcode 9 同时支持 Swift 4 和 Swift 3.2。如果需要，你可以逐个指定项目中的每个 <code>target</code> 使用 Swift 3.2 还是 Swift 4。 迁移到 并不是完全不受限制的，你可能需要重新部分代码来兼容修的 SDK .而且由于 Swift ABI 仍然尚未稳定所以你需要用 Xcode 9 重新编译你依赖。<br>当你准备迁移到 Swift 4 ， Xcode 9 再次提供一个工具来帮助你，你可以点击<code>Edit/Convert/To Current Swift Syntax…</code>来呼出转换工具。<br>选择你想要转换的 <code>targets</code> 后，Xcode 将提示你 <code>Objective-C</code> 推导中的偏好， 选择推荐的选项通过限制推断来减少你的二进制文件的大小。（关于这个的主题的更多信息，参阅<a href="https://www.raywenderlich.com/163857/whats-new-swift-4#objc" target="_blank" rel="noopener">Limiting @objc Inference</a>）.<br><img src="https://ooo.0o0.ooo/2017/06/17/59451fb0ae5dd.png" alt=""><br>为了更好地理解你代码中预期的变化，我们将首先介绍Swift 4 中变更的API。</p><h2 id="API-Changes"><a href="#API-Changes" class="headerlink" title="API Changes"></a>API Changes</h2><p>在跳转到 Swift 4 加入的新特新前，让我们首先来看一下它对现有的 API 有哪些改成／改善。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>Swift 4 中的 <code>String</code> 获得了很多应得的称赞。这个提案包含大量的改变，让我们来分解下<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0163-string-revision-1.md" target="_blank" rel="noopener">[SE-0163]</a>：</p><p>怕你怀旧，strings 再次变为集合像之前的 Swift2.0 一样。这个改变使你不在依赖 <code>characters</code> 数组，现在你直接遍历 <code>String</code> 对象 ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> galaxy = <span class="string">"Milky Way 🐮"</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> galaxy &#123;</span><br><span class="line">  <span class="built_in">print</span>(char)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不仅仅是循环，你还可以获得 <code>Sequence</code> 和 <code>Collection</code> 所有附加功能;</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">galaxy.<span class="built_in">count</span>       <span class="comment">// 11</span></span><br><span class="line">galaxy.isEmpty     <span class="comment">// false</span></span><br><span class="line">galaxy.<span class="built_in">dropFirst</span>() <span class="comment">// "ilky Way 🐮"</span></span><br><span class="line"><span class="type">String</span>(galaxy.reversed()) <span class="comment">// "🐮 yaW ykliM"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Filter out any none ASCII characters</span></span><br><span class="line">galaxy.<span class="built_in">filter</span> &#123; char <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">let</span> isASCII = char.unicodeScalars.<span class="built_in">reduce</span>(<span class="literal">true</span>, &#123; $<span class="number">0</span> &amp;&amp; $<span class="number">1</span>.isASCII &#125;)</span><br><span class="line">  <span class="keyword">return</span> isASCII</span><br><span class="line">&#125; <span class="comment">// "Milky Way "</span></span><br></pre></td></tr></table></figure><p>ASCII 的例子演示了对 <code>Character</code> 一个小改进,现在你可以从 <code>Character</code> 直接访问 <code>UnicodeScalarView</code>,以前你需要实例化一个新的 <code>String</code><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0178-character-unicode-view.md" target="_blank" rel="noopener">[SE-0178]</a>。</p><p>还有一个附加的时候 <code>StringProtocol</code>,<br>它声明以前在 <code>String</code> 上声明的大部分功能。这种变化的原因是为了改善切片工作。Swift 4 在 <code>String</code> 中增加了 <code>Substring</code> 类型，继承自 <code>StringProtocol</code>。</p><p><code>String</code> 和 <code>Substring</code> 都实现了 <code>StringProtocol</code>,这是两者几乎拥有相同的功能。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// Grab a subsequence of String</span></span><br><span class="line"><span class="keyword">let</span> endIndex = galaxy.index(galaxy.startIndex, offsetBy: <span class="number">3</span>)</span><br><span class="line"><span class="keyword">var</span> milkSubstring = galaxy[galaxy.startIndex...endIndex]   <span class="comment">// "Milk"</span></span><br><span class="line">type(of: milkSubstring)   <span class="comment">// Substring.Type</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Concatenate a String onto a Substring</span></span><br><span class="line">milkSubstring += <span class="string">"🥛"</span>     <span class="comment">// "Milk🥛"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a String from a Substring</span></span><br><span class="line"><span class="keyword">let</span> milkString = <span class="type">String</span>(milkSubstring) <span class="comment">// "Milk🥛"</span></span><br></pre></td></tr></table></figure><p>另一项改进是 <code>String</code> 对字形簇的解读，这个决议来自于Unicode 9的改编。在这之前，多码点（multiple code points）构成的 unicode 字符的 count 结果大于1，这通常发生在选定肤色的emoji表情，下面是一些前后对比：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"👩‍💻"</span>.<span class="built_in">count</span> <span class="comment">// Now: 1, Before: 2</span></span><br><span class="line"><span class="string">"👍🏽"</span>.<span class="built_in">count</span> <span class="comment">// Now: 1, Before: 2</span></span><br><span class="line"><span class="string">"👨‍❤️‍💋‍👨"</span>.<span class="built_in">count</span> <span class="comment">// Now: 1, Before, 4</span></span><br></pre></td></tr></table></figure><p>这只是<a href="https://github.com/apple/swift/blob/master/docs/StringManifesto.md" target="_blank" rel="noopener">[String Manifesto]</a>的一部分，你可以阅读预期改动的原始动机和被提议后的答复。</p><h3 id="Dictionary-和-Set"><a href="#Dictionary-和-Set" class="headerlink" title="Dictionary 和 Set"></a>Dictionary 和 Set</h3><p>至于 <code>Collection</code> 类型，<code>Set</code> 和  <code>Dictionary</code> 不是很直观，幸运的是，Swift 团队给了它们很多必要的关照 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0165-dict.md" target="_blank" rel="noopener">[SE-0165]</a>.</p><h4 id="Sequence-Based-Initialization"><a href="#Sequence-Based-Initialization" class="headerlink" title="Sequence Based Initialization"></a>Sequence Based Initialization</h4><p>第一个是可以创建一个dictionary 从序列的键值对（元组）：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nearestStarNames = [<span class="string">"Proxima Centauri"</span>, <span class="string">"Alpha Centauri A"</span>, <span class="string">"Alpha Centauri B"</span>, <span class="string">"Barnard's Star"</span>, <span class="string">"Wolf 359"</span>]</span><br><span class="line"><span class="keyword">let</span> nearestStarDistances = [<span class="number">4.24</span>, <span class="number">4.37</span>, <span class="number">4.37</span>, <span class="number">5.96</span>, <span class="number">7.78</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dictionary from sequence of keys-values</span></span><br><span class="line"><span class="keyword">let</span> starDistanceDict = <span class="type">Dictionary</span>(uniqueKeysWithValues: <span class="built_in">zip</span>(nearestStarNames, nearestStarDistances)) </span><br><span class="line"><span class="comment">// ["Wolf 359": 7.78, "Alpha Centauri B": 4.37, "Proxima Centauri": 4.24, "Alpha Centauri A": 4.37, "Barnard's Star": 5.96]</span></span><br></pre></td></tr></table></figure><h4 id="Duplicate-Key-Resolution"><a href="#Duplicate-Key-Resolution" class="headerlink" title="Duplicate Key Resolution"></a>Duplicate Key Resolution</h4><p>现在你可以用喜欢的方式复制 keys 实例化一个 dictionary，这使我们不需要写繁琐的键值对关系语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Random vote of people&apos;s favorite stars</span><br><span class="line">let favoriteStarVotes = [&quot;Alpha Centauri A&quot;, &quot;Wolf 359&quot;, &quot;Alpha Centauri A&quot;, &quot;Barnard&apos;s Star&quot;]</span><br><span class="line"></span><br><span class="line">// Merging keys with closure for conflicts</span><br><span class="line">let mergedKeysAndValues = Dictionary(zip(favoriteStarVotes, repeatElement(1, count: favoriteStarVotes.count)), uniquingKeysWith: +) // [&quot;Barnard&apos;s Star&quot;: 1, &quot;Alpha Centauri A&quot;: 2, &quot;Wolf 359&quot;: 1]</span><br></pre></td></tr></table></figure><p>上面的代码使用了 zip 和 缩写 + 处理重复的 keys 和冲突的 values 。</p><blockquote><p>注： 如果你不熟悉 <code>zip</code> 你可以快速的在Apple的 <a href="https://developer.apple.com/documentation/swift/1541125-zip" target="_blank" rel="noopener">[Swift Documentation]</a> 学习它。</p></blockquote><h4 id="Filtering"><a href="#Filtering" class="headerlink" title="Filtering"></a>Filtering</h4><p> <code>Dictionary</code> 和 <code>Set</code> 现在可以筛选将结果赋给一个新的同类型对象。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Filtering results into dictionary rather than array of tuples</span></span><br><span class="line"><span class="keyword">let</span> closeStars = starDistanceDict.<span class="built_in">filter</span> &#123; $<span class="number">0</span>.value &lt; <span class="number">5.0</span> &#125;</span><br><span class="line">closeStars <span class="comment">// Dictionary: ["Proxima Centauri": 4.24, "Alpha Centauri A": 4.37, "Alpha Centauri B": 4.37]</span></span><br></pre></td></tr></table></figure><h4 id="Dictionary-Mapping"><a href="#Dictionary-Mapping" class="headerlink" title="Dictionary Mapping"></a>Dictionary Mapping</h4><p><code>Dictionary</code> 获得了一个非常有用的方法用来 map 它的 values：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mapping values directly resulting in a dictionary</span></span><br><span class="line"><span class="keyword">let</span> mappedCloseStars = closeStars.mapValues &#123; <span class="string">"\($0)"</span> &#125;</span><br><span class="line">mappedCloseStars <span class="comment">// ["Proxima Centauri": "4.24", "Alpha Centauri A": "4.37", "Alpha Centauri B": "4.37"]</span></span><br></pre></td></tr></table></figure><h4 id="Dictionary-Default-Values"><a href="#Dictionary-Default-Values" class="headerlink" title="Dictionary Default Values"></a>Dictionary Default Values</h4><p>访问 <code>Dictionary</code>  的 value 时，常见的做法是使用 <code>nil coalescing operator</code> 来给一个默认值（译者注 ：<code>a != nil ? a! : b</code> 的方式，见<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html" target="_blank" rel="noopener">[Basic Operators]</a>。在 Swift 4 现在有了简洁的多的方式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Subscript with a default value</span></span><br><span class="line"><span class="keyword">let</span> siriusDistance = mappedCloseStars[<span class="string">"Wolf 359"</span>, <span class="keyword">default</span>: <span class="string">"unknown"</span>] <span class="comment">// "unknown"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Subscript with a default value used for mutating</span></span><br><span class="line"><span class="keyword">var</span> starWordsCount: [<span class="type">String</span>: <span class="type">Int</span>] = [:]</span><br><span class="line"><span class="keyword">for</span> starName <span class="keyword">in</span> nearestStarNames &#123;</span><br><span class="line">  <span class="keyword">let</span> numWords = starName.<span class="built_in">split</span>(separator: <span class="string">" "</span>).<span class="built_in">count</span></span><br><span class="line">  starWordsCount[starName, <span class="keyword">default</span>: <span class="number">0</span>] += numWords <span class="comment">// Amazing </span></span><br><span class="line">&#125;</span><br><span class="line">starWordsCount <span class="comment">// ["Wolf 359": 2, "Alpha Centauri B": 3, "Proxima Centauri": 2, "Alpha Centauri A": 3, "Barnard's Star": 2]</span></span><br></pre></td></tr></table></figure><p>以前这种住转变需要包裹在臃肿的 <code>if-let</code> 语句中，在 Swift 4 中可能只需要一行。</p><h4 id="Dictionary-Grouping"><a href="#Dictionary-Grouping" class="headerlink" title="Dictionary Grouping"></a>Dictionary Grouping</h4><p>另一个出奇有用的附加功能可以从 <code>Sequence</code> 实例化一个 <code>Dictionary</code> ，并将其分组：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Grouping sequences by computed key</span></span><br><span class="line"><span class="keyword">let</span> starsByFirstLetter = <span class="type">Dictionary</span>(grouping: nearestStarNames) &#123; $<span class="number">0</span>.first! &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ["B": ["Barnard's Star"], "A": ["Alpha Centauri A", "Alpha Centauri B"], "W": ["Wolf 359"], "P": ["Proxima Centauri"]]</span></span><br></pre></td></tr></table></figure><p>当对特定的数据进行归类时会变得很方便。</p><h4 id="Reserving-Capacity"><a href="#Reserving-Capacity" class="headerlink" title="Reserving Capacity"></a>Reserving Capacity</h4><p><code>Sequence</code> 和 <code>Dictionary</code> 现在都具备保留容量的功能。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Improved Set/Dictionary capacity reservation</span></span><br><span class="line">starWordsCount.capacity  <span class="comment">// 6</span></span><br><span class="line">starWordsCount.reserveCapacity(<span class="number">20</span>) <span class="comment">// reserves at _least_ 20 elements of capacity</span></span><br><span class="line">starWordsCount.capacity <span class="comment">// 24</span></span><br></pre></td></tr></table></figure><p>在这些类型中，重新分配是代价高昂的任务。使用 <code>reserveCapacity(_:)</code> 可以很容易的改善执行效率。<br>这是一个巨大的改变，所以务必检查这两个类型，想办法使用这些新特性来优化你的代码。</p><h4 id="Private-Access-Modifier"><a href="#Private-Access-Modifier" class="headerlink" title="Private Access Modifier"></a>Private Access Modifier</h4><p>在 Swift 3 上大家并不是很喜欢加入的 <code>fileprivate</code>, 理论上，它很不错，但是实践中它的用法时常让人困惑。在成员内部使用 <code>private</code>,当你在相同的文件共享成员变量的访问时很少使用 <code>fileprivate</code>。<br>问题是 Swift 鼓励使用 extensions 来将代码按逻辑分组。extension 在成员变量的原始作用域之外，导致广泛地需要使用 <code>fileprivate</code> 。<br>Swift 4 意识到上述在类型和 extension 共享访问权的初衷，但是它只在相同的源文件中有效 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0169-improve-interaction-between-private-declarations-and-extensions.md" target="_blank" rel="noopener">[SE-0169]</a>:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SpaceCraft</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> warpCode: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(warpCode: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.warpCode = warpCode</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SpaceCraft</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">goToWarpSpeed</span><span class="params">(warpCode: String)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> warpCode == <span class="keyword">self</span>.warpCode &#123; <span class="comment">// Error in Swift 3 unless warpCode is fileprivate</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"Do it Scotty!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> enterprise = <span class="type">SpaceCraft</span>(warpCode: <span class="string">"KirkIsCool"</span>)</span><br><span class="line"><span class="comment">//enterprise.warpCode  // error: 'warpCode' is inaccessible due to 'private' protection level</span></span><br><span class="line">enterprise.goToWarpSpeed(warpCode: <span class="string">"KirkIsCool"</span>) <span class="comment">// "Do it Scotty!"</span></span><br></pre></td></tr></table></figure><p>这让你可以实现原本 <code>fileprivate</code> 的目的，而不需要杂乱的代码。</p><h2 id="API-Additions"><a href="#API-Additions" class="headerlink" title="API Additions"></a>API Additions</h2><p>现在让我们一起来看一下 Swift 4 的新特性，这些改变只是一下简单的附加功能，不会破坏你现有的代码。</p><h3 id="Archival-and-Serialization"><a href="#Archival-and-Serialization" class="headerlink" title="Archival and Serialization"></a>Archival and Serialization</h3><p>目前为止，Swift 中自定义类型的序列化和归档有太多的坑，对于 <code>class</code> 类型，你需要子类化 <code>NSObject</code> 并且实现 <code>NSCoding</code>协议。</p><p>而像 <code>struct</code> 和 <code>enum</code> 这样的值类型，需要创建一个子类通过扩展 <code>NSObject</code> 和 <code>NSCoding</code> 的 hacks 来实现。<br>Swift 4  解决了这三种类型的序列化问题<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0166-swift-archival-serialization.md" target="_blank" rel="noopener">[SE-0166]</a>:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CuriosityLog</span>: <span class="title">Codable</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Discovery</span>: <span class="title">String</span>, <span class="title">Codable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> rock, water, martian</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> sol: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">var</span> discoveries: [<span class="type">Discovery</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a log entry for Mars sol 42</span></span><br><span class="line"><span class="keyword">let</span> logSol42 = <span class="type">CuriosityLog</span>(sol: <span class="number">42</span>, discoveries: [.rock, .rock, .rock, .rock])</span><br></pre></td></tr></table></figure><p> 上面的例子中，你可以看到在 Swift 中类型的 <code>Encodable</code> 和 <code>Decodable</code> 只需要实现 <code>Codable</code> 协议，如果所有的属性都实现了 <code>Codable</code> 协议，那么编译器将自动完成协议的实现。<br>对对象进行编码，你需要把它交给一个编码器，Swift 4 开始积极的实现编码器。每个编码器按照不同的 schemes 。（注：该提案的部分内容仍在开发中）：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonEncoder = <span class="type">JSONEncoder</span>() <span class="comment">// One currently available encoder</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Encode the data</span></span><br><span class="line"><span class="keyword">let</span> jsonData = <span class="keyword">try</span> jsonEncoder.encode(logSol42)</span><br><span class="line"><span class="comment">// Create a String from the data</span></span><br><span class="line"><span class="keyword">let</span> jsonString = <span class="type">String</span>(data: jsonData, encoding: .utf8) <span class="comment">// "&#123;"sol":42,"discoveries":["rock","rock","rock","rock"]&#125;"</span></span><br></pre></td></tr></table></figure><p>它将一个对象自编码成 JSON 对象，请务必检查 <code>JSONEncoder</code> 的属性来定制它的输出。</p><p>过程的最后一部分是解码数据为一个具体对象：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonDecoder = <span class="type">JSONDecoder</span>() <span class="comment">// Pair decoder to JSONEncoder</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Attempt to decode the data to a CuriosityLog object</span></span><br><span class="line"><span class="keyword">let</span> decodedLog = <span class="keyword">try</span> jsonDecoder.decode(<span class="type">CuriosityLog</span>.<span class="keyword">self</span>, from: jsonData)</span><br><span class="line">decodedLog.sol         <span class="comment">// 42</span></span><br><span class="line">decodedLog.discoveries <span class="comment">// [rock, rock, rock, rock]</span></span><br></pre></td></tr></table></figure><p>通过使用 Swift 4的 encoding/decoding，获得Swift的类型安全性。同时不依赖 @objc 协议的开销和限制。</p><h3 id="Key-Value-Coding"><a href="#Key-Value-Coding" class="headerlink" title="Key-Value Coding"></a>Key-Value Coding</h3><p>目前为止，由于函数是一个闭包的缘故，你可以在不调用函数的情况下对函数进行引用。你不能做的通过属性访问是没有暴露借口的私有变量。</p><p>令人兴奋的是 Swift 4 可以用对象的 Key paths 来 get/set 私有变量。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Lightsaber</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> blue, green, red</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> color: <span class="type">Color</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForceUser</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> lightsaber: <span class="type">Lightsaber</span></span><br><span class="line">  <span class="keyword">var</span> master: <span class="type">ForceUser</span>?</span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>, lightsaber: <span class="type">Lightsaber</span>, master: <span class="type">ForceUser</span>? = <span class="literal">nil</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.lightsaber = lightsaber</span><br><span class="line">    <span class="keyword">self</span>.master = master</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sidious = <span class="type">ForceUser</span>(name: <span class="string">"Darth Sidious"</span>, lightsaber: <span class="type">Lightsaber</span>(color: .red))</span><br><span class="line"><span class="keyword">let</span> obiwan = <span class="type">ForceUser</span>(name: <span class="string">"Obi-Wan Kenobi"</span>, lightsaber: <span class="type">Lightsaber</span>(color: .blue))</span><br><span class="line"><span class="keyword">let</span> anakin = <span class="type">ForceUser</span>(name: <span class="string">"Anakin Skywalker"</span>, lightsaber: <span class="type">Lightsaber</span>(color: .blue), master: obiwan)</span><br></pre></td></tr></table></figure><p>在这里你创建了一些 <code>ForceUser</code> 实例，通过设置他们的 name 、 lightsaber 和 master 。创建 key path ，你只需使用一个反斜杠后面跟上你感兴趣的属性:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create reference to the ForceUser.name key path</span></span><br><span class="line"><span class="keyword">let</span> nameKeyPath = \<span class="type">ForceUser</span>.name</span><br><span class="line"></span><br><span class="line"><span class="comment">// Access the value from key path on instance</span></span><br><span class="line"><span class="keyword">let</span> obiwanName = obiwan[keyPath: nameKeyPath]  <span class="comment">// "Obi-Wan Kenobi"</span></span><br></pre></td></tr></table></figure><p>在这个例子中，你给 <code>ForceUser</code> 的 <code>name</code> 属性创建了一个 key path。然后使用这个 key path 通过新的下标 <code>keyPath</code> 这个下下标现在在每种类型都可以用。</p><p>这里有一些通过 key path 访问子对象，设置属性，构建 key path 引用的例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use keypath directly inline and to drill down to sub objects</span></span><br><span class="line"><span class="keyword">let</span> anakinSaberColor = anakin[keyPath: \<span class="type">ForceUser</span>.lightsaber.color]  <span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Access a property on the object returned by key path</span></span><br><span class="line"><span class="keyword">let</span> masterKeyPath = \<span class="type">ForceUser</span>.master</span><br><span class="line"><span class="keyword">let</span> anakinMasterName = anakin[keyPath: masterKeyPath]?.name  <span class="comment">// "Obi-Wan Kenobi"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Change Anakin to the dark side using key path as a setter</span></span><br><span class="line">anakin[keyPath: masterKeyPath] = sidious</span><br><span class="line">anakin.master?.name <span class="comment">// Darth Sidious</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Note: not currently working, but works in some situations</span></span><br><span class="line"><span class="comment">// Append a key path to an existing path</span></span><br><span class="line"><span class="comment">//let masterNameKeyPath = masterKeyPath.appending(path: \ForceUser.name)</span></span><br><span class="line"><span class="comment">//anakin[keyPath: masterKeyPath] // "Darth Sidious"</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">key path 之美在于它在 <span class="type">Swift</span> 中是坚固的，不像 <span class="type">Objective</span>-<span class="type">C</span> 中的 string 那么凌乱。</span><br><span class="line"></span><br><span class="line">### <span class="type">Multi</span>-line <span class="type">String</span> <span class="type">Literals</span></span><br><span class="line">创建多行文本是很多编程语言一个非常普遍的特性。<span class="type">Swift</span> <span class="number">4</span> 加入这个简单但是有用的语法，用三个引号包装文本[[<span class="type">SE</span>-<span class="number">0168</span>]](https:<span class="comment">//github.com/apple/swift-evolution/blob/master/proposals/0168-multi-line-string-literals.md)：</span></span><br><span class="line"></span><br><span class="line">```swift</span><br><span class="line"><span class="keyword">let</span> star = <span class="string">"⭐️"</span></span><br><span class="line"><span class="keyword">let</span> introString = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">  A long time ago in a galaxy far,</span></span><br><span class="line"><span class="string">  far away....</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  You could write multi-lined strings</span></span><br><span class="line"><span class="string">  without "</span>escaping<span class="string">" single quotes.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  The indentation of the closing quotes</span></span><br><span class="line"><span class="string">       below deside where the text line</span></span><br><span class="line"><span class="string">  begins.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  You can even dynamically add values</span></span><br><span class="line"><span class="string">  from properties: \(star)</span></span><br><span class="line"><span class="string">  "</span><span class="string">""</span></span><br><span class="line"><span class="built_in">print</span>(introString) <span class="comment">// prints the string exactly as written above with the value of star</span></span><br></pre></td></tr></table></figure><p>当构建 <code>XML/JSON</code> 信息或者 UI 上的长文字排版时，这是极为有用的。</p><h3 id="One-Sided-Ranges"><a href="#One-Sided-Ranges" class="headerlink" title="One-Sided Ranges"></a>One-Sided Ranges</h3><p>为了减少冗余和提高可读性，标准库现在可以使用半开区间来推断开始和结束的索引<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0172-one-sided-ranges.md" target="_blank" rel="noopener">[SE-0172]</a>。<br>从集合的一个索引到开始或者结束的索引创建一个区间，有了非常便利的方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Collection Subscript</span></span><br><span class="line"><span class="keyword">var</span> planets = [<span class="string">"Mercury"</span>, <span class="string">"Venus"</span>, <span class="string">"Earth"</span>, <span class="string">"Mars"</span>, <span class="string">"Jupiter"</span>, <span class="string">"Saturn"</span>, <span class="string">"Uranus"</span>, <span class="string">"Neptune"</span>]</span><br><span class="line"><span class="keyword">let</span> outsideAsteroidBelt = planets[<span class="number">4</span>...] <span class="comment">// Before: planets[4..&lt;planets.endIndex]</span></span><br><span class="line"><span class="keyword">let</span> firstThree = planets[..&lt;<span class="number">4</span>]          <span class="comment">// Before: planets[planets.startIndex..&lt;4]</span></span><br></pre></td></tr></table></figure><p>如你所见，半开区间不需要指明开始或者结束的索引。</p><h4 id="Infinite-Sequence"><a href="#Infinite-Sequence" class="headerlink" title="Infinite Sequence"></a>Infinite Sequence</h4><p>同时允许你从一个可计算的开始索引定义一个无限的 <code>Sequence</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Infinite range: 1...infinity</span></span><br><span class="line"><span class="keyword">var</span> numberedPlanets = <span class="type">Array</span>(<span class="built_in">zip</span>(<span class="number">1</span>..., planets))</span><br><span class="line"><span class="built_in">print</span>(numberedPlanets) <span class="comment">// [(1, "Mercury"), (2, "Venus"), ..., (8, "Neptune")]</span></span><br><span class="line"></span><br><span class="line">planets.append(<span class="string">"Pluto"</span>)</span><br><span class="line">numberedPlanets = <span class="type">Array</span>(<span class="built_in">zip</span>(<span class="number">1</span>..., planets))</span><br><span class="line"><span class="built_in">print</span>(numberedPlanets) <span class="comment">// [(1, "Mercury"), (2, "Venus"), ..., (9, "Pluto")]</span></span><br></pre></td></tr></table></figure><h4 id="Pattern-Matching"><a href="#Pattern-Matching" class="headerlink" title="Pattern Matching"></a>Pattern Matching</h4><p>半开区间另一个很好的用法是模式匹配：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pattern matching</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">temperature</span><span class="params">(planetNumber: Int)</span></span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> planetNumber &#123;</span><br><span class="line">  <span class="keyword">case</span> ...<span class="number">2</span>: <span class="comment">// anything less than or equal to 2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Too hot"</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>...: <span class="comment">// anything greater than or equal to 4</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Too cold"</span>)</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Justtttt right"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">temperature(planetNumber: <span class="number">3</span>) <span class="comment">// Earth</span></span><br></pre></td></tr></table></figure><h3 id="Generic-Subscripts"><a href="#Generic-Subscripts" class="headerlink" title="Generic Subscripts"></a>Generic Subscripts</h3><p>下标是一种直观且重要的访问数据的方式，为了改善效率，现在可以用在普通类型<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0148-generic-subscripts.md" target="_blank" rel="noopener">[SE-0148]</a>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GenericDictionary</span>&lt;<span class="title">Key</span>: <span class="title">Hashable</span>, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> data: [<span class="type">Key</span>: <span class="type">Value</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(data: [<span class="type">Key</span>: <span class="type">Value</span>]) &#123;</span><br><span class="line">    <span class="keyword">self</span>.data = data</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">subscript</span>&lt;<span class="type">T</span>&gt;(key: <span class="type">Key</span>) -&gt; <span class="type">T</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> data[key] <span class="keyword">as</span>? <span class="type">T</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子中的返回值是泛型，你可以在这个泛型中这样使用下标：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dictionary of type: [String: Any]</span></span><br><span class="line"><span class="keyword">var</span> earthData = <span class="type">GenericDictionary</span>(data: [<span class="string">"name"</span>: <span class="string">"Earth"</span>, <span class="string">"population"</span>: <span class="number">7500000000</span>, <span class="string">"moons"</span>: <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// Automatically infers return type without "as? String"</span></span><br><span class="line"><span class="keyword">let</span> name: <span class="type">String</span>? = earthData[<span class="string">"name"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// Automatically infers return type without "as? Int"</span></span><br><span class="line"><span class="keyword">let</span> population: <span class="type">Int</span>? = earthData[<span class="string">"population"</span>]</span><br></pre></td></tr></table></figure><p>不仅仅是返回值可以是泛型的，下标也可以是泛型的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">extension GenericDictionary &#123;</span><br><span class="line">  subscript&lt;Keys: Sequence&gt;(keys: Keys) -&gt; [Value] where Keys.Iterator.Element == Key &#123;</span><br><span class="line">    var values: [Value] = []</span><br><span class="line">    for key in keys &#123;</span><br><span class="line">      if let value = data[key] &#123;</span><br><span class="line">        values.append(value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return values</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Array subscript value</span><br><span class="line">let nameAndMoons = earthData[[&quot;moons&quot;, &quot;name&quot;]]        // [1, &quot;Earth&quot;]</span><br><span class="line">// Set subscript value</span><br><span class="line">let nameAndMoons2 = earthData[Set([&quot;moons&quot;, &quot;name&quot;])]  // [1, &quot;Earth&quot;]</span><br></pre></td></tr></table></figure><p>在这个例子中你可以看到，传递两个不同的 <code>Sequence</code> 类型（<code>Array</code> 和 <code>Set</code>）会得到各自的 vlaues 组成的数组。</p><h2 id="Miscellaneous"><a href="#Miscellaneous" class="headerlink" title="Miscellaneous"></a>Miscellaneous</h2><p>以上列举的囊括了swift4中最大变化的部分, 现在让我们快速看看其他方面的小改动。</p><h3 id="MutableCollection-swapAt"><a href="#MutableCollection-swapAt" class="headerlink" title="MutableCollection.swapAt(_:_:)"></a>MutableCollection.swapAt(_:_:)</h3><p><code>MutableCollection</code> 现在有 <code>swapAt(_:_:)</code> 方法，正如它的命名，用来交换给定下标的值 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0173-swap-indices.md" target="_blank" rel="noopener">[SE-0173]</a>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Very basic bubble sort with an in-place swap</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span>&lt;T: Comparable&gt;<span class="params">(<span class="number">_</span> array: [T])</span></span> -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line">  <span class="keyword">var</span> sortedArray = array</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;sortedArray.<span class="built_in">count</span> - <span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>..&lt;sortedArray.<span class="built_in">count</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> sortedArray[j-<span class="number">1</span>] &gt; sortedArray[j] &#123;</span><br><span class="line">        sortedArray.swapAt(j-<span class="number">1</span>, j) <span class="comment">// New MutableCollection method</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sortedArray</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bubbleSort([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]) <span class="comment">// [0, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><h3 id="Associated-Type-Constraints"><a href="#Associated-Type-Constraints" class="headerlink" title="Associated Type Constraints"></a>Associated Type Constraints</h3><p>现在你可以使用 <code>where</code> 从句约束相关的类型<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0142-associated-types-constraints.md" target="_blank" rel="noopener">[SE-0142]</a>:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MyProtocol</span> </span>&#123;</span><br><span class="line">  associatedtype <span class="type">Element</span></span><br><span class="line">  associatedtype <span class="type">SubSequence</span> : <span class="type">Sequence</span> <span class="keyword">where</span> <span class="type">SubSequence</span>.<span class="type">Iterator</span>.<span class="type">Element</span> == <span class="type">Iterator</span>.<span class="type">Element</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过约束协议，<code>associatedtype</code> 声明可以直接限制它们的值,不必在大费周折。</p><h3 id="Class-and-Protocol-Existential"><a href="#Class-and-Protocol-Existential" class="headerlink" title="Class and Protocol Existential"></a>Class and Protocol Existential</h3><p>最后一个从 <code>Objective-C</code> 搬过来的特性是可以定义一个类型遵守一类或一组协议<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0156-subclass-existentials.md" target="_blank" rel="noopener">[SE-0156]</a>:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MyProtocol</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">View</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewSubclass</span>: <span class="title">View</span>, <span class="title">MyProtocol</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> delegate: (<span class="type">View</span> &amp; <span class="type">MyProtocol</span>)?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myClass = <span class="type">MyClass</span>()</span><br><span class="line"><span class="comment">//myClass.delegate = View() // error: cannot assign value of type 'View' to type '(View &amp; MyProtocol)?'</span></span><br><span class="line">myClass.delegate = <span class="type">ViewSubclass</span>()</span><br></pre></td></tr></table></figure><h3 id="Limiting-objc-Inference"><a href="#Limiting-objc-Inference" class="headerlink" title="Limiting @objc Inference"></a>Limiting @objc Inference</h3><p>要向 Objective-C 暴露你的 Swift API ，可以使用 <code>@objc</code> 编译标志。在很多情况下编译器可以为你推导。但是大量的推理会导致三个主要的问题:</p><ol><li>可能显著的增加你的二进制文件大小</li><li>有时候无法准确的推倒</li><li>增加构成  Objective-C  方法选择器冲突的风险</li></ol><p>Swift 4 通过限制 <code>@objc</code> 的推导来解决这个问题，这意味着当你需要 <code>Objective-C</code> 所有的动态调度功能是，你主要明确的使用 <code>@objc</code>。<br>举几个你需要修改的示例包括 <code>private</code> 方法，动态声明 和 <code>NSObject</code>  基类的一些方法。</p><h3 id="NSNumber-Bridging"><a href="#NSNumber-Bridging" class="headerlink" title="NSNumber Bridging"></a>NSNumber Bridging</h3><p>在很长时间内，<code>NSNumber</code> 和 Swift numbers 有很多奇怪的行为都困扰这这门语言。Swift 4 干掉了这些bug <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0170-nsnumber_bridge.md" target="_blank" rel="noopener">[SE-0170]</a>：</p><p>这里有一个示范：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n = <span class="type">NSNumber</span>(value: <span class="number">999</span>)</span><br><span class="line"><span class="keyword">let</span> v = n <span class="keyword">as</span>? <span class="type">UInt8</span> <span class="comment">// Swift 4: nil, Swift 3: 231</span></span><br></pre></td></tr></table></figure><p>在 Swift 3 中会出现的怪异现象，如果数字溢出，它会简单的从0开始。在这个例子中 999% 2 ^ 8 = 231。</p><p>Swift 4 解决了这个问题，只有当强转后的类型可以安全的容纳时，才会返回值。</p><h2 id="Swift-Package-Manager"><a href="#Swift-Package-Manager" class="headerlink" title="Swift Package Manager"></a>Swift Package Manager</h2><p>近几个月，Swift 包管理有许多更新，一些比较大的更新如下：</p><ol><li>从 branch 或者 comint hash 中获取依赖</li><li>对可接受的包更多的支配</li><li>用更为常见的解决方案代替不直观的命令</li><li>能够定义用来编译的 Swift 版本</li><li>为每个 target 指明 source files 路径。</li></ol><p>这些是 SPM 在必经之路上迈出的大步伐，它还有很长的路要走，我们可以通过积极参与提议来帮忙完善它。</p><p>有关最近已解决的提案的详细描述，请查看<a href="https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20170605/001019.html" target="_blank" rel="noopener">Swift 4 Package Manager Update</a></p><h2 id="Still-In-Progress"><a href="#Still-In-Progress" class="headerlink" title="Still In Progress"></a>Still In Progress</h2><p>在撰写本文时，队列中仍有15个接受的提案。如果你想一睹为快，访问<a href="https://apple.github.io/swift-evolution/" target="_blank" rel="noopener">Swift Evolution Proposals</a> 然后用 <code>Accepted</code> 筛选.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻译自&lt;a href=&quot;https://www.raywenderlich.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Raywenderlich&lt;/a&gt;的文章：&lt;a href=&quot;https://www.raywenderlich.com/163857/whats-new-swift-4#&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;What’s New in Swift 4?&lt;/a&gt;&lt;br&gt;Swift 4 是Swift下一个大版本更新，预计在2017年秋推出Beta版。其重点在与Swift3的兼容性和ABI稳定性。&lt;br&gt;本文重点介绍一些这个版本中显著影响你代码的变化。好了，让我们开始吧。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://www.devorz.com/tags/iOS/"/>
    
      <category term="Swift" scheme="https://www.devorz.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C内存管理知识梳理</title>
    <link href="https://www.devorz.com/2016/11/28/Automatic-Reference-Counting/"/>
    <id>https://www.devorz.com/2016/11/28/Automatic-Reference-Counting/</id>
    <published>2016-11-28T15:06:13.000Z</published>
    <updated>2018-07-13T06:24:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>内存管理相关知识梳理<br><a id="more"></a></p><h2 id="黄金法则"><a href="#黄金法则" class="headerlink" title="黄金法则:"></a>黄金法则:</h2><h3 id="自己生成的对象，自己持有"><a href="#自己生成的对象，自己持有" class="headerlink" title="自己生成的对象，自己持有"></a>自己生成的对象，自己持有</h3><p>使用<code>allloc</code>,<code>new</code>,<code>copy</code>,<code>mutableCopy</code>名称开头的方法名，意味着生成的对象自己持有。但<code>allocate</code>,<code>newer</code>,<code>copying</code>,<code>mutableCopyed</code>例外。<br>其内部实现为(<code>alloc</code>开头为例)：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">id</span>)allocObject&#123;</span><br><span class="line">    <span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc]init];</span><br><span class="line">    <span class="keyword">return</span> objc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非自己生成的对象，自己也能持有。"><a href="#非自己生成的对象，自己也能持有。" class="headerlink" title="非自己生成的对象，自己也能持有。"></a>非自己生成的对象，自己也能持有。</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="comment">//取得的对象存在，但自己不持有</span></span><br><span class="line"></span><br><span class="line">[obj <span class="keyword">retain</span>];</span><br><span class="line"><span class="comment">//自己持有对象</span></span><br></pre></td></tr></table></figure><p>其内部实现:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">id</span>)object&#123;</span><br><span class="line">    <span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc]init];</span><br><span class="line">    [obj autorelease];</span><br><span class="line">    <span class="keyword">return</span> objc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不在需要自己持有的对象时，调用release释放；"><a href="#不在需要自己持有的对象时，调用release释放；" class="headerlink" title="不在需要自己持有的对象时，调用release释放；"></a>不在需要自己持有的对象时，调用release释放；</h3><h3 id="无法释放非自己持有的对象；"><a href="#无法释放非自己持有的对象；" class="headerlink" title="无法释放非自己持有的对象；"></a>无法释放非自己持有的对象；</h3><h3 id="Autorelease"><a href="#Autorelease" class="headerlink" title="Autorelease"></a>Autorelease</h3><p>即自动释放，类似于C语言中的局部变量的特性。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; imageCount ;i++)&#123;</span><br><span class="line"><span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc]init];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">读入图像</span></span><br><span class="line"><span class="comment">大量产生autorelease的对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">[pool drain];</span><br><span class="line"><span class="comment">/*autorelease对象被一起release*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ARC"><a href="#ARC" class="headerlink" title="ARC:"></a>ARC:</h2><h3 id="不能使用retain-release-retainCount-autorelease"><a href="#不能使用retain-release-retainCount-autorelease" class="headerlink" title="不能使用retain/release/retainCount/autorelease"></a>不能使用retain/release/retainCount/autorelease</h3><h3 id="不能使用NSAllocateObject-NSdeallocateObject"><a href="#不能使用NSAllocateObject-NSdeallocateObject" class="headerlink" title="不能使用NSAllocateObject/NSdeallocateObject"></a>不能使用NSAllocateObject/NSdeallocateObject</h3><h3 id="必须遵守内存管理方法命名规则"><a href="#必须遵守内存管理方法命名规则" class="headerlink" title="必须遵守内存管理方法命名规则"></a>必须遵守内存管理方法命名规则</h3><p>MRC中对象的生成和持有必须以以下名称开头：</p><ul><li><code>alloc</code></li><li><code>new</code></li><li><code>copy</code></li><li><code>mutableCopy</code><br>ARC时，追加一条规则：<br>除<code>initialize</code>方法外，方法名以<code>init</code>开头时，必须是实例方法，必须返回对象(不可以返回<code>void</code>)，对象必须是id类型或该方法声明类的对象类型。</li></ul><h3 id="不能显式调用dealloc"><a href="#不能显式调用dealloc" class="headerlink" title="不能显式调用dealloc"></a>不能显式调用dealloc</h3><p><code>[super dealloc]</code>也不需要，ARC会自动处理。</p><h3 id="使用-autoreleasepool块代替NSAutoreleasePool。"><a href="#使用-autoreleasepool块代替NSAutoreleasePool。" class="headerlink" title="使用@autoreleasepool块代替NSAutoreleasePool。"></a>使用@autoreleasepool块代替NSAutoreleasePool。</h3><p>ARC时<code>NSAutoreleasePool</code>类不可以使用.</p><h3 id="不能使用NSZone"><a href="#不能使用NSZone" class="headerlink" title="不能使用NSZone"></a>不能使用NSZone</h3><h3 id="对象型变量不能作为C语言结构体的成员"><a href="#对象型变量不能作为C语言结构体的成员" class="headerlink" title="对象型变量不能作为C语言结构体的成员"></a>对象型变量不能作为C语言结构体的成员</h3><h3 id="显式转换id和void"><a href="#显式转换id和void" class="headerlink" title="显式转换id和void*"></a>显式转换id和void*</h3><h2 id="所有权修饰符："><a href="#所有权修饰符：" class="headerlink" title="所有权修饰符："></a>所有权修饰符：</h2><table><thead><tr><th>修饰符</th><th>意义</th></tr></thead><tbody><tr><td>__strong</td><td>强引用，默认修饰符</td></tr><tr><td>__weak</td><td>弱引用，对象废弃时会自动置nil;</td></tr><tr><td>__unsafe_unretained</td><td>弱引用，但对象废弃时不会自动置nil</td></tr><tr><td>__autoreleaseing</td><td>= =..极少显式调用。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内存管理相关知识梳理&lt;br&gt;
    
    </summary>
    
    
      <category term="MRC" scheme="https://www.devorz.com/tags/MRC/"/>
    
      <category term="ARC" scheme="https://www.devorz.com/tags/ARC/"/>
    
      <category term="内存管理" scheme="https://www.devorz.com/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Objective-c中属性名以new开头编译报错</title>
    <link href="https://www.devorz.com/2016/10/30/iOS-Property-Prefix-new/"/>
    <id>https://www.devorz.com/2016/10/30/iOS-Property-Prefix-new/</id>
    <published>2016-10-29T17:18:40.000Z</published>
    <updated>2018-07-13T06:24:13.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>property follows cocoa naming convention for returning ‘owned’ objects</p></blockquote><a id="more"></a><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>当做一个修改密码的页面的时候，很自然的把新密码的输入框命名为<code>newPasswordTextField</code>，此时编译不通过。错误提示如下：</p><blockquote><p>property follows cocoa naming convention for returning ‘owned’ objects</p></blockquote><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p><a href="https://developer.apple.com/library/content/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html" target="_blank" rel="noopener"> Transitioning to ARC Release Notes</a>中写道： </p><blockquote><p>You cannot give an accessor a name that begins with new. This in turn means that you can’t, for example, declare a property whose name begins with new unless you specify a different getter</p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Won't work:</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *newTitle;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Works:</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">getter</span>=theNewTitle) <span class="built_in">NSString</span> *newTitle;</span><br></pre></td></tr></table></figure><p>在MRC时代，有约定如果方法名以alloc、copy、init、mutableCopy和new开头且有返回值时，return 对象时先调用一次<code>retain</code>。ARC时代只是把<code>retain</code>交给编译器去自动添加。所以当属性名以<code>new</code>开头时生成的<code>getter</code>方法会有内存管理的语义冲突。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><ol><li>重命名属性</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>)<span class="built_in">UITextField</span> *theNewPasswordTextField;</span><br></pre></td></tr></table></figure><ol start="2"><li>修改<code>getter</code>方法名</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">getter</span>=theNewPasswordTextField) <span class="built_in">UITextField</span> *newPasswordTextField;</span><br></pre></td></tr></table></figure><ol start="3"><li>指明 <strong>attribute</strong>((objc_method_family(none)))</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifndef __has_attribute</span></span><br><span class="line"><span class="meta">#define __has_attribute(x) 0  // Compatibility with non-clang compilers</span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#if __has_attribute(objc_method_family)</span></span><br><span class="line"><span class="meta">#define BV_OBJC_METHOD_FAMILY_NONE __attribute__((objc_method_family(none)))</span></span><br><span class="line"><span class="meta">#else</span></span><br><span class="line"><span class="meta">#define BV_OBJC_METHOD_FAMILY_NONE</span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> : <span class="title">UIViewController</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>)<span class="built_in">UITextField</span> *newPasswordTextField;</span><br><span class="line">- (<span class="built_in">UITextField</span> *)newPasswordTextField BV_OBJC_METHOD_FAMILY_NONE;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote><p><a href="http://stackoverflow.com/questions/6327448/semantic-issue-propertys-synthesized-getter-follows-cocoa-naming-convention-fo" target="_blank" rel="noopener">stackoverflow1⃣️</a></p></blockquote><blockquote><p><a href="http://stackoverflow.com/questions/24308162/property-name-starting-with-new-prefix-leads-to-bad-access-error-in-ios" target="_blank" rel="noopener">stackoverflow2⃣️</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;property follows cocoa naming convention for returning ‘owned’ objects&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Objective-c" scheme="https://www.devorz.com/tags/Objective-c/"/>
    
  </entry>
  
  <entry>
    <title>Auto Layout总结</title>
    <link href="https://www.devorz.com/2016/10/13/AutoLayout/"/>
    <id>https://www.devorz.com/2016/10/13/AutoLayout/</id>
    <published>2016-10-13T14:01:49.000Z</published>
    <updated>2018-07-13T06:24:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>Auto Layout 小总结。<br><a id="more"></a></p><h1 id="Auto-Layout-介绍"><a href="#Auto-Layout-介绍" class="headerlink" title="Auto Layout 介绍"></a>Auto Layout 介绍</h1><h2 id="Auto-Layout的由来"><a href="#Auto-Layout的由来" class="headerlink" title="Auto Layout的由来"></a>Auto Layout的由来</h2><p>2011年初次出现在OS X 10.7中，初次出现在iOS是在2012年的iOS6.旨在取代基于<code>spring</code> 和 <code>strut</code> 的 <code>Autosizing</code>. </p><p><code>Auto Layout</code> 的前身是 <a href="https://en.wikipedia.org/wiki/Cassowary" target="_blank" rel="noopener">Cassowary</a>.</p><h2 id="使用Auto-Layout-的好处"><a href="#使用Auto-Layout-的好处" class="headerlink" title="使用Auto Layout 的好处"></a>使用Auto Layout 的好处</h2><ol><li>几何关系。</li><li>内容驱动的布局。</li><li>优先级规则。</li><li>检查和模块化。</li><li>与 <code>Autosizing</code> 兼容。</li></ol><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>1.可满足性。（不得有冲突）<br>2.充分性。 （信息足以确定大小和位置）</p><h2 id="约束属性"><a href="#约束属性" class="headerlink" title="约束属性"></a>约束属性</h2><p>属性：</p><table><thead><tr><th>Auto Layout Attributes</th><th>Notes</th></tr></thead><tbody><tr><td>Height</td><td>高</td></tr><tr><td>Width</td><td>宽</td></tr><tr><td>Top</td><td>上侧</td></tr><tr><td>Bottom</td><td>下侧</td></tr><tr><td>BaseLine</td><td>文本基线</td></tr><tr><td>Leading</td><td>前边</td></tr><tr><td>Trailing</td><td>后边</td></tr><tr><td>Left</td><td>左</td></tr><tr><td>Right</td><td>右</td></tr><tr><td>CenterX</td><td>横向中点</td></tr><tr><td>CenterY</td><td>纵向中点</td></tr></tbody></table><p>在从左到右的语言环境中 <code>Leading</code> 与 <code>Left</code> 、<code>Trailing</code> 与 <code>Right</code>相等，从右到左的语言环境中（如阿拉伯语，希伯来语），则会对调。</p><p>关系：</p><table><thead><tr><th>NSLayoutRelation</th><th>Notes</th></tr></thead><tbody><tr><td>LessThanOrEqual</td><td>小于或者等于</td></tr><tr><td>Equal</td><td>等于</td></tr><tr><td>GreaterThanOrEqual</td><td>大于或者等于</td></tr></tbody></table><h2 id="关于那些丢失的视图"><a href="#关于那些丢失的视图" class="headerlink" title="关于那些丢失的视图"></a>关于那些丢失的视图</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> translatesAutoresizingMaskIntoConstraints</span><br></pre></td></tr></table></figure><blockquote><p>By default, the property is set to YES for any view you programmatically create. If you add views in Interface Builder, the system automatically sets this property to NO.<br>–Apple 的文档写到，使用纯代码时，该属性默认为 <code>YES</code>,<br>当使用 <code>Interface Builder</code> 时，系统将自动将它设为<code>NO</code>.<br>使用<code>Auto Layout</code>应该先把该属性设为 <code>NO</code> ,否则View还是会按照以往的 <code>AutoresizingMask</code> 进行计算.</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)mas_makeConstraints:(<span class="keyword">void</span>(^)(MASConstraintMaker *))block &#123;</span><br><span class="line">    <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</span><br><span class="line">    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:<span class="keyword">self</span>];</span><br><span class="line">    block(constraintMaker);</span><br><span class="line">    <span class="keyword">return</span> [constraintMaker install];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span> *)mas_updateConstraints:(<span class="keyword">void</span>(^)(MASConstraintMaker *))block &#123;</span><br><span class="line">    <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</span><br><span class="line">    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:<span class="keyword">self</span>];</span><br><span class="line">    constraintMaker.updateExisting = <span class="literal">YES</span>;</span><br><span class="line">    block(constraintMaker);</span><br><span class="line">    <span class="keyword">return</span> [constraintMaker install];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span> *)mas_remakeConstraints:(<span class="keyword">void</span>(^)(MASConstraintMaker *make))block &#123;</span><br><span class="line">    <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</span><br><span class="line">    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:<span class="keyword">self</span>];</span><br><span class="line">    constraintMaker.removeExisting = <span class="literal">YES</span>;</span><br><span class="line">    block(constraintMaker);</span><br><span class="line">    <span class="keyword">return</span> [constraintMaker install];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在著名的自动布局框架<code>Masonry</code>中，可以看到，每次更改约束，都会先<code>self.translatesAutoresizingMaskIntoConstraints = NO;</code>;</p><h2 id="有歧义的布局"><a href="#有歧义的布局" class="headerlink" title="有歧义的布局"></a>有歧义的布局</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"UIView+Test.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIView</span> (<span class="title">Test</span>)</span></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)jat_testAmbiguity&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"&lt;%@:0x%0x&gt;:%@"</span>,</span><br><span class="line">          <span class="keyword">self</span>.class.description,(<span class="keyword">int</span>)<span class="keyword">self</span>,</span><br><span class="line">          <span class="keyword">self</span>.hasAmbiguousLayout?<span class="string">@"有歧义"</span>:<span class="string">@"没有歧义"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UIView</span> *view <span class="keyword">in</span> <span class="keyword">self</span>.subviews) &#123;</span><br><span class="line">        [view Jatstar_testAmbiguity];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// hasAmbiguousLayout: 检查约束是否有歧义</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="内在内容的大小"><a href="#内在内容的大小" class="headerlink" title="内在内容的大小"></a>内在内容的大小</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGSize</span>)intrinsicContentSize</span><br></pre></td></tr></table></figure><p>视图的本身大小，根据视图的内容决定，如Label的文字，ImageView 的图片。<br>当视图存在内在大小时，可以只设置视图的位置，它将和内在大小共同构成无歧义的布局。</p><h2 id="压缩阻力和内在吸附"><a href="#压缩阻力和内在吸附" class="headerlink" title="压缩阻力和内在吸附"></a>压缩阻力和内在吸附</h2><p><code>Auto Layout</code> 遇到两个相互矛盾的请求时，只会让优先级更高的起作用。</p><ol><li>压缩阻力：视图压缩的能力。默认值750；</li><li>内容吸附：视图抵抗拉伸的能力。默认值250.</li></ol><p>水平轴和垂直轴分别设置。取值范围都是[1,1000]</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置视图抵抗压缩的优先级。</span></span><br><span class="line">- (<span class="keyword">void</span>)setContentCompressionResistancePriority:(<span class="built_in">UILayoutPriority</span>)priority forAxis:(<span class="built_in">UILayoutConstraintAxis</span>)axis</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置视图抵抗拉伸的优先级。</span></span><br><span class="line">- (<span class="keyword">void</span>)setContentHuggingPriority:(<span class="built_in">UILayoutPriority</span>)priority forAxis:(<span class="built_in">UILayoutConstraintAxis</span>)axis</span><br></pre></td></tr></table></figure><h2 id="图像装饰元素"><a href="#图像装饰元素" class="headerlink" title="图像装饰元素"></a>图像装饰元素</h2><p>使用<code>Auto Layout</code> 布局 <code>UIImageView</code> 时，自动布局无法对图片中的硬编码装饰元素（如：高光，阴影）作出调整，你必须自己指出。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> *insetImage = [shadowedImage imageWithAlignmentRectInsets:<span class="built_in">UIEdgeInsetsMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">20</span>, <span class="number">20</span>)];</span><br></pre></td></tr></table></figure><p> UIEdgeInsets 构造器：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 计算 inset</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param alignmentRect (不包括阴影)</span></span><br><span class="line"><span class="comment"> @param imageBounds (包括阴影)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @return intset</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">UIKIT_STATIC_INLINE</span> <span class="built_in">UIEdgeInsets</span> BuildInset(<span class="built_in">CGRect</span> alignmentRect ,<span class="built_in">CGRect</span> imageBounds)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGRect</span> targetRect = <span class="built_in">CGRectIntersection</span>(alignmentRect, imageBounds);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIEdgeInsets</span> inset;</span><br><span class="line">    inset.left = <span class="built_in">CGRectGetMidX</span>(targetRect) - <span class="built_in">CGRectGetMidX</span>(imageBounds);</span><br><span class="line">    inset.right = <span class="built_in">CGRectGetMaxX</span>(imageBounds) - <span class="built_in">CGRectGetMaxX</span>(targetRect);</span><br><span class="line">    inset.top = <span class="built_in">CGRectGetMidY</span>(targetRect) - <span class="built_in">CGRectGetMidY</span>(imageBounds);</span><br><span class="line">    inset.bottom = <span class="built_in">CGRectGetMaxY</span>(imageBounds) - <span class="built_in">CGRectGetMaxY</span>(targetRect);</span><br><span class="line">    <span class="keyword">return</span> inset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="约束-1"><a href="#约束-1" class="headerlink" title="约束"></a>约束</h1><h2 id="约束类型"><a href="#约束类型" class="headerlink" title="约束类型"></a>约束类型</h2><ul><li><code>NSLayoutContraint</code> ：公有，布局约束。用于设置view在view tree之间的关系，自身大小等。</li><li><code>NSContentSizeLayourConstraint</code> ：私有，内容大小约束。主要包含 内容吸附 和内容压缩。</li><li><code>NSAutoresizingMaskLayoutConstrin</code> ：私有，由 <code>AutosizingMask</code> 转换到 <code>AutoLayout</code>系统中的约束表达。</li><li><code>_UILayoutSupportConstraint</code> ：私有，iOS7中新增，包括 <code>topLayoutGuide</code> 和 <code>bottomLayoutGuide</code> ,用于防止视图与状态栏之类的障碍物重合。</li><li><code>NSIBPrototypingLayoutConstraint</code>：“私有，iOS7新增，如果在 <code>Interface Builder</code> 中添加控件，并且没有在StoryBoard中为该控件设置约束，但是标注了使用<code>AutoLayout</code>的话,在运行时期，系统会默认为该控件添加该约束。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 避免 navigationBar 和 tabBar 的遮挡</span></span><br><span class="line">[testView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    <span class="built_in">UIView</span> *topLayoutGuide = (<span class="keyword">id</span>)<span class="keyword">self</span>.topLayoutGuide;</span><br><span class="line">    make.top.equalTo(topLayoutGuide.mas_bottom);</span><br><span class="line">    <span class="built_in">UIView</span> *bottomLayoutGuide = (<span class="keyword">id</span>)<span class="keyword">self</span>.bottomLayoutGuide;</span><br><span class="line">    make.bottom.equalTo(bottomLayoutGuide.mas_top);</span><br><span class="line">    make.left.equalTo(<span class="keyword">self</span>.view);</span><br><span class="line">    make.right.equalTo(<span class="keyword">self</span>.view);  </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h2 id="约束的优先级"><a href="#约束的优先级" class="headerlink" title="约束的优先级"></a>约束的优先级</h2><p>衡量约束重要性的指标。 同一约束条件 <code>AutoLayout</code> 会使优先级更高的约束生效。<br>优先级是浮点数，但通常用其整数表达。</p><h2 id="线性公式"><a href="#线性公式" class="headerlink" title="线性公式"></a>线性公式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;view1.attr1 = view2.attr2 * multiplier + constant&quot;</span><br></pre></td></tr></table></figure><p>这里可以是 <code>==</code> <code>&lt;=</code> <code>&gt;=</code>;</p><h2 id="构建约束的方式"><a href="#构建约束的方式" class="headerlink" title="构建约束的方式"></a>构建约束的方式</h2><ul><li><code>Interface Builder</code>.</li><li><code>Visual Format Language</code>（VFL）.</li><li><code>NSLayoutConstraint实例</code></li></ul><h1 id="UIScrollView-And-Autolayout"><a href="#UIScrollView-And-Autolayout" class="headerlink" title="UIScrollView And Autolayout"></a>UIScrollView And Autolayout</h1><blockquote><p>UIScrollView依靠与其subviews之间的约束来确定ContentSize的大小</p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIView</span> *container = [<span class="built_in">UIView</span> new];</span><br><span class="line">[scrollView addSubview:container];</span><br><span class="line">[container mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.edges.equalTo(scrollView);</span><br><span class="line">    make.width.equalTo(scrollView);</span><br><span class="line">    make.height.equalTo(scrollView).multipliedBy(<span class="number">2.0</span>);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//ContentSize的width等于scrollView的width </span></span><br><span class="line"><span class="comment">//ContentSize的height等于scrollView的height的两倍</span></span><br></pre></td></tr></table></figure><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><blockquote><p><a href="https://developer.apple.com/library/content/technotes/tn2154/_index.html" target="_blank" rel="noopener">UIScrollView And Autolayout</a><br><a href="https://www.amazon.cn/iOS-Auto-Layout-Demystified-Sadun-Erica/dp/0321967194/ref=sr_1_4?ie=UTF8&amp;qid=1477760019&amp;sr=8-4&amp;keywords=autolayout" target="_blank" rel="noopener">iOS Auto Layout Demystified</a><br><a href="https://github.com/SnapKit/Masonry" target="_blank" rel="noopener">GitHub - SnapKit/Masonry</a><br><a href="http://adad184.com/2014/09/28/use-masonry-to-quick-solve-autolayout/" target="_blank" rel="noopener">Masonry介绍与使用实践</a><br><a href="http://adad184.com/2015/12/01/scrollview-under-autolayout/" target="_blank" rel="noopener">UIScrollview与Autolayout的那点事</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Auto Layout 小总结。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Background Execution--iOS后台运行机制总结</title>
    <link href="https://www.devorz.com/2016/09/27/iOS-Background-Execution/"/>
    <id>https://www.devorz.com/2016/09/27/iOS-Background-Execution/</id>
    <published>2016-09-27T13:32:57.000Z</published>
    <updated>2018-07-13T06:24:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS后台运行机制的探索总结。</p><a id="more"></a><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>为了能够把系统资源合理的分配给用户正在使用的前台应用以及改善电池的使用寿命，iOS中，对于许多应用，当应用不在前台运行时，系统会将以一种简短的方式将其挂起。<a href="https://developer.apple.com/library/content/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/BackgroundExecution/BackgroundExecution.html" target="_blank" rel="noopener">(For many apps, the background state is just a brief stop on the way to the app being suspended)</a>.</p><p>绝大部分应用程序简单的挂起就足够了，但是也有一部分应用以正当的理由在后台继续运行。比如，远足应用需要随时跟踪用户位置，音频应用可能需要后台播放音乐，还有一些应用需要后台下载，以便零延迟的向用户呈现内容。<br>当你认为你的应用程序需要在后台运行，iOS提供的技术可以高效的帮你完成。其实现大致分为以下三种：</p><ol><li><p>应用前台时，开启短任务（short task）。</p></li><li><p>将下载任务交给系统处理，从而使程序被暂停或终止时，下载任务仍然继续。</p></li><li><p>特定类型任务，应用可以申报一个或多个后台运行模式（background execution modes.）。</p></li></ol><blockquote><p>Always try to avoid doing any background work unless doing so improves the overall user experience. An app might move to the background because the user launched a different app or because the user locked the device and is not using it right now. In both situations, the user is signaling that your app does not need to be doing any meaningful work right now. Continuing to run in such conditions will only drain the device’s battery and might lead the user to force quit your app altogether. So be mindful about the work you do in the background and avoid it when you can.</p></blockquote><h2 id="执行有限长度的任务"><a href="#执行有限长度的任务" class="headerlink" title="执行有限长度的任务"></a>执行有限长度的任务</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)applicationDidEnterBackground:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">UIBackgroundTaskIdentifier</span> bgTask;</span><br><span class="line">    bgTask = [application beginBackgroundTaskWithName:<span class="string">@"MyTask"</span> expirationHandler:^&#123;</span><br><span class="line">        <span class="comment">// 处理未完成的任务</span></span><br><span class="line">        <span class="comment">// 结束任务.</span></span><br><span class="line">        [application endBackgroundTask:bgTask];</span><br><span class="line">        bgTask = <span class="built_in">UIBackgroundTaskInvalid</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 异步执行，保证使用耗时任务时能够及时调用 endBackgroundTask： 方法</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 耗时任务</span></span><br><span class="line">        </span><br><span class="line">        [application endBackgroundTask:bgTask];</span><br><span class="line">        bgTask = <span class="built_in">UIBackgroundTaskInvalid</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于时间的限制，只能执行有限时长的任务。</p><h2 id="后台下载"><a href="#后台下载" class="headerlink" title="后台下载"></a>后台下载</h2><p>为了支持后台传输，您必须配置NSURLSession适当的对象。要配置会话，必须先创建一个<code>NSURLSessionConfiguration</code>对象，并设置多个属性为适当的值。然后，该配置对象传递给适当的初始化方法NSURLSession创建会话时。</p><p>创建一处后台下载的任务方法：</p><ol><li>使用<code>backgroundSessionConfigurationWithIdentifier:</code>创建<code>NSURLSessionConfiguration</code>配置对象 .</li><li>设置配置对象的<code>sessionSendsLaunchEvents</code>属性为YES。</li><li>大文件时推荐把<code>discretionary</code>属性设为<code>YES</code>。</li><li>适当的配置其他属性。</li><li>使用配置好的<code>NSURLSessionConfiguration</code>对象来创建你的<code>NSURLSession</code>对象。</li></ol><h2 id="执行长时间运行的任务"><a href="#执行长时间运行的任务" class="headerlink" title="执行长时间运行的任务"></a>执行长时间运行的任务</h2><p>在iOS中，只有特定类型的应用程序允许在后台运行：</p><ol><li>后台播放音频的软件，如音乐播放器。</li><li>后台录制音频的软件。</li><li>是用户在任何时候知晓自己的位置，如导航应用。</li><li>VoIP应用，如QQ电话。</li><li>需要定期下载和更新内容的应用。</li><li>定期从外部附件收到更新的应用。</li></ol><table><thead><tr><th>Xcode background mode</th><th>UIBackgroundModes value</th><th>描述</th></tr></thead><tbody><tr><td>Audio and AirPlay</td><td>audio</td><td>后台播放或录制音频</td></tr><tr><td>Loaction updates</td><td>location</td><td>实时告知用户自己的位置</td></tr><tr><td>Voice over IP</td><td>voip</td><td>网络电话</td></tr><tr><td>Newsstand downloads</td><td>newsstand-content</td><td>后台下载杂志或报纸内容</td></tr><tr><td>External accessory communication</td><td>external accessory</td><td>外部附件</td></tr><tr><td>Uses Bluetooth LE accessories</td><td>bluetooth-central</td><td>蓝牙</td></tr><tr><td>Acts as a Bluetooth LE accessory</td><td>bluetooth-periphral</td><td>蓝牙</td></tr><tr><td>Background fetch</td><td>fetch</td><td>定期下载少了来自网络的内容</td></tr><tr><td>Remote-notification</td><td>remote-notification</td><td>收到推送时，下载相关内容。</td></tr></tbody></table><h3 id="跟踪用户位置"><a href="#跟踪用户位置" class="headerlink" title="跟踪用户位置"></a>跟踪用户位置</h3><p>有以下三种方式在后台跟踪用户的位置：</p><ol><li>位置发生显著的变化服务（significant-change location service）。（推荐）</li><li>前台定位服务（Foreground-only location services）。</li><li>后台定位服务（Background location services）。</li></ol><p>显著的位置变化服务：基站定位，位置发生大的改变时唤醒应用在后台执行更新。<br>前台定位服务只有在前台时才可以获取到用户的位置信息。<br>后台定位服务不能阻止系统挂起应用，但是有新的位置数据更新时，能够唤醒应用执行任务。</p><blockquote><p><a href="Location and Maps Programming Guide">《Location and Maps Programming Guide》</a></p></blockquote><h3 id="播放和录制背景声音"><a href="#播放和录制背景声音" class="headerlink" title="播放和录制背景声音"></a>播放和录制背景声音</h3><p>当UIBackgroundModes项包含audio值，播放或录制音频文件时，应用将不能被暂停,但是播放或录制停止时，系统将挂起应用。<br>注：早期为了后台运行，会弄一个无声音的音频文件不停播放。现在被发现被拒。</p><blockquote><p><a href="https://developer.apple.com/library/content/documentation/Audio/Conceptual/AudioSessionProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007875" target="_blank" rel="noopener">《Audio Session Programming Guide》</a></p></blockquote><h3 id="构建VoIP应用"><a href="#构建VoIP应用" class="headerlink" title="构建VoIP应用"></a>构建VoIP应用</h3><blockquote><p><a href="https://developer.apple.com/library/content/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/StrategiesforImplementingYourApp/StrategiesforImplementingYourApp.html#//apple_ref/doc/uid/TP40007072-CH5-SW13" target="_blank" rel="noopener">《Tips for Developing a VoIP App》</a></p></blockquote><h3 id="不失时机地获取少量的内容"><a href="#不失时机地获取少量的内容" class="headerlink" title="不失时机地获取少量的内容"></a>不失时机地获取少量的内容</h3><p>需要在<code>Info.plist</code> 文件中 <code>UIBackgroundModes</code>项增加 <code>fetch</code> 类型。系统将在最佳时机唤醒或启动应用到后台，调用<code>application:performFetchWithCompletionHandler:</code>方法，使用该方法来检查新的内容，有内容时启动下载操作。<br>建议使用NSURLSession类来启动和管理您的下载，有关如何使用这个类来管理上传和下载任务的信息，请参阅<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html#//apple_ref/doc/uid/10000165i" target="_blank" rel="noopener">《URL Session Programming Guide》</a>。</p><h3 id="使用推送通知来启动下载"><a href="#使用推送通知来启动下载" class="headerlink" title="使用推送通知来启动下载"></a>使用推送通知来启动下载</h3><p>需要在 <code>Info.plist</code> 文件中 <code>UIBackgroundModes</code> 项增加 <code>remote-notification</code> 类型,远程通知payload中必须包含  <code>content-available</code> key，而且，value 为 1。<br>满足以上条件，收到通知时 系统将唤醒后台的程序 ，并调用  <code>delegate</code> 的 <code>application:didReceiveRemoteNotification:fetchCompletionHandler:</code>。</p><h3 id="后台下载杂志"><a href="#后台下载杂志" class="headerlink" title="后台下载杂志"></a>后台下载杂志</h3><blockquote><p><a href="https://developer.apple.com/reference/newsstandkit" target="_blank" rel="noopener">《Newsstand Kit Framework Reference》</a>.</p></blockquote><h3 id="连接外部附件"><a href="#连接外部附件" class="headerlink" title="连接外部附件"></a>连接外部附件</h3><p>任何支持连接外部附件的后台处理更新的应用程序必须遵循几个基本原则：</p><ul><li>应用必须提供一个接口，它允许用户启动和停止附件更新事件的传输。该接口应该在合适的时候打开或关闭。</li><li>一旦被唤醒，应用程序有10秒左右来处理数据。理想的情况下，就应该尽可能快地处理数据，并允许自身被再次挂起。如果需要更多的时间，有必要的情况下，应用程序可以使用该<code>beginBackgroundTaskWithExpirationHandler:</code>方法来请求额外的时间。</li></ul><h3 id="连接蓝牙外设"><a href="#连接蓝牙外设" class="headerlink" title="连接蓝牙外设"></a>连接蓝牙外设</h3><blockquote><p><a href="https://developer.apple.com/library/content/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/CoreBluetoothBackgroundProcessingForIOSApps/PerformingTasksWhileYourAppIsInTheBackground.html#//apple_ref/doc/uid/TP40013257-CH7-SW1" target="_blank" rel="noopener">《Core Bluetooth Programming Guide》</a>.</p></blockquote><h2 id="在后台运行时获取用户的关注"><a href="#在后台运行时获取用户的关注" class="headerlink" title="在后台运行时获取用户的关注"></a>在后台运行时获取用户的关注</h2><p>本地通知示例代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)scheduleAlarmForDate:(<span class="built_in">NSDate</span>*)theDate</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIApplication</span>* app = [<span class="built_in">UIApplication</span> sharedApplication];</span><br><span class="line">    <span class="built_in">NSArray</span>*    oldNotifications = [app scheduledLocalNotifications];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Clear out the old notification before scheduling a new one.</span></span><br><span class="line">    <span class="keyword">if</span> ([oldNotifications count] &gt; <span class="number">0</span>)</span><br><span class="line">        [app cancelAllLocalNotifications];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Create a new notification.</span></span><br><span class="line">    <span class="built_in">UILocalNotification</span>* alarm = [[<span class="built_in">UILocalNotification</span> alloc] init];</span><br><span class="line">    <span class="keyword">if</span> (alarm)</span><br><span class="line">    &#123;</span><br><span class="line">        alarm.fireDate = theDate;</span><br><span class="line">        alarm.timeZone = [<span class="built_in">NSTimeZone</span> defaultTimeZone];</span><br><span class="line">        alarm.repeatInterval = <span class="number">0</span>;</span><br><span class="line">        alarm.soundName = <span class="string">@"alarmsound.caf"</span>;</span><br><span class="line">        alarm.alertBody = <span class="string">@"Time to wake up!"</span>;</span><br><span class="line"> </span><br><span class="line">        [app scheduleLocalNotification:alarm];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以取消计划的通知或获得通知的清单。有关这些方法的详细信息，请参阅<a href="https://developer.apple.com/reference/uikit/uiapplication" target="_blank" rel="noopener">《UIApplication Class Reference》</a>。有关配置本地通知的更多信息，请参阅<a href="https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/Introduction.html#//apple_ref/doc/uid/TP40008194" target="_blank" rel="noopener">《Local and Remote Notification Programming Guide》</a>。</p><h2 id="做一个负责的后台应用"><a href="#做一个负责的后台应用" class="headerlink" title="做一个负责的后台应用"></a>做一个负责的后台应用</h2><p>当涉及到利用系统资源和硬件,前台应用始终拥有高于后台应用程序的优先级。在后台运行的应用程序需要对这种差异有所准备，并调整自己的行为。具体来说，应用在后台时应遵循以下原则：</p><ul><li>不要做任何的OpenGL ES代码调用。</li><li>被暂停之前取消所有的Bonjour相关的服务。</li><li>准备处理基于sockets 的 连接错误。</li><li>进入到后台之前保存您的应用程序的状态。参阅<a href="https://developer.apple.com/library/content/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/StrategiesforImplementingYourApp/StrategiesforImplementingYourApp.html#//apple_ref/doc/uid/TP40007072-CH5-SW2" target="_blank" rel="noopener">《Preserving Your App’s Visual Appearance Across Launches》</a></li><li>移动到后台时删除对不需要的对象的强引用。</li><li>停止使用共享系统资源。如地址簿，日历数据库。如果在后台使用这些戏院，程序将被系统杀死。</li><li>避免刷新windows和views.</li><li>响应连接和断开了外部附件的通知.<a href="https://developer.apple.com/library/content/featuredarticles/ExternalAccessoryPT/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009502" target="_blank" rel="noopener">《External Accessory Programming Topics》</a>.</li><li>清理主动警告的视图。系统不会自动dismiss <code>UIActionSheet</code>和 <code>UIAlertView</code> ,进入后台之前，你可能需要做一些清理工作。</li><li>进入后台之前隐藏敏感信息。如密码等，应该在<code>applicationDidEnterBackground:</code>之前隐藏，防止被后台快照捕捉到。</li><li>考虑到诸多限制，在后台运行时，应该做最少的工作。</li></ul><h2 id="禁止后台运行"><a href="#禁止后台运行" class="headerlink" title="禁止后台运行"></a>禁止后台运行</h2><p>如果你希望你的程序任何时候都不要在后台运行，可以在程序的<code>Info.plist</code>中 设置 <code>UIApplicationExitsOnSuspend</code>key，并将值设置<code>YES</code>。<br>此时如果用户按下Home键，delegate的 <code>applicationWillTerminate:</code>方法将被调用，大约五秒后，程序将被终止。<br>使用场景比较小。如果后台执行显著增加了程序的复杂性，关闭后台运行也许是一个简单的方案。另外，如果程序需要消耗大量的内存，而且不能轻易的释放任何信息，系统可能会迅速杀死你的应用为其他应用让路，这种情况下选择禁止后台运行，会产生相同的结果，并节省开发时间和精力。</p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li><a href="https://developer.apple.com/library/content/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/BackgroundExecution/BackgroundExecution.html" target="_blank" rel="noopener">《Background Execution》</a>.</li><li><a href="http://www.aichengxu.com/view/6564145" target="_blank" rel="noopener">《iOS后台运行机制-实践总结》</a>.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS后台运行机制的探索总结。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://www.devorz.com/tags/iOS/"/>
    
      <category term="Background-Execution" scheme="https://www.devorz.com/tags/Background-Execution/"/>
    
  </entry>
  
  <entry>
    <title>《iOS Animations by Tutorials》笔记</title>
    <link href="https://www.devorz.com/2016/08/18/iOS-Animations-by-Tutorials/"/>
    <id>https://www.devorz.com/2016/08/18/iOS-Animations-by-Tutorials/</id>
    <published>2016-08-18T14:43:12.000Z</published>
    <updated>2018-07-13T06:24:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>Raywenderlich的《iOS Animations by Tutorials》 读书笔记<br><a id="more"></a></p><h1 id="View-Animations"><a href="#View-Animations" class="headerlink" title="View Animations"></a>View Animations</h1><h2 id="Getting-Started-With-View-Animations"><a href="#Getting-Started-With-View-Animations" class="headerlink" title="Getting Started With View Animations"></a>Getting Started With View Animations</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UIView</span>.animateWithDuration(<span class="number">0.5</span>, animations: &#123;</span><br><span class="line"><span class="keyword">self</span>.heading.center.x += <span class="keyword">self</span>.view.bounds.width</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//duration 持续时间</span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UIView</span>.animateWithDuration(<span class="number">0.5</span>, delay: <span class="number">0.4</span>, options: [], animations: &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.password.center.x += <span class="keyword">self</span>.view.bounds.width</span><br><span class="line">&#125;, completion: <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">//delay：延迟时间(单位为秒)</span></span><br></pre></td></tr></table></figure><h3 id="动画属性-Animatable-properties"><a href="#动画属性-Animatable-properties" class="headerlink" title="动画属性 (Animatable properties)"></a>动画属性 (Animatable properties)</h3><ol><li>Position and size（<code>bounds</code>/<code>frame</code>/<code>center</code>）.</li><li>Appearance (<code>backgroundColor</code>/<code>alpha</code>).</li><li>Transform (ratation,scale,position).</li></ol><h3 id="动画选项（Animation-options）"><a href="#动画选项（Animation-options）" class="headerlink" title="动画选项（Animation options）"></a>动画选项（Animation options）</h3><ol><li>Repeating<ul><li><code>.Repeat</code> : 重复执行</li><li><code>.Autoreverse</code> 与<code>.Repeat</code>连用，重复往返执行。</li></ul></li><li>Animation easing<ul><li><code>.Linear</code> 匀速。</li><li><code>.CurveEaseIn</code> 起始缓慢，逐渐加速。</li><li><code>.CurveEaseOut</code> 起始迅速，逐渐减速。</li><li><code>.CurveEaseInOut</code> 起始缓慢，加速一半时间后减速结束。</li></ul></li></ol><h2 id="Springs-弹簧"><a href="#Springs-弹簧" class="headerlink" title="Springs(弹簧)"></a>Springs(弹簧)</h2><p><img src="http://ww3.sinaimg.cn/large/a50bf7fdjw1f6ybw7irzrj208206zt8s.jpg" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">animateWithDuration</span>(<span class="title">_</span> <span class="title">duration</span>: <span class="title">NSTimeInterval</span>, <span class="title">delay</span> <span class="title">delay</span>: <span class="title">NSTimeInterval</span>, <span class="title">usingSpringWithDamping</span> <span class="title">dampingRatio</span>: <span class="title">CGFloat</span>, <span class="title">initialSpringVelocity</span> <span class="title">velocity</span>: <span class="title">CGFloat</span>, <span class="title">options</span> <span class="title">options</span>: <span class="title">UIViewAnimationOptions</span>, <span class="title">animations</span> <span class="title">animations</span>: () -&gt; <span class="title">Void</span>, <span class="title">completion</span> <span class="title">completion</span>: ((<span class="title">Bool</span>) -&gt; <span class="title">Void</span>)?)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//<span class="title">dampingRatio</span> : 弹簧的阻尼 取值范围0-1；越小弹簧波动越大；</span></span><br><span class="line"><span class="class">//<span class="title">velocity</span> : 初始速度。 如果总距离为200<span class="title">pt</span>，移动速度为100<span class="title">pt</span>／<span class="title">s</span>，那么改值设0.5.以此类推。</span></span><br></pre></td></tr></table></figure><h2 id="Transitions"><a href="#Transitions" class="headerlink" title="Transitions"></a>Transitions</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Apple文档示例：</span></span><br><span class="line">[<span class="built_in">UIView</span> transitionWithView:containerView</span><br><span class="line">           duration:<span class="number">0.2</span></span><br><span class="line">           options:<span class="built_in">UIViewAnimationOptionTransitionFlipFromLeft</span></span><br><span class="line">           animations:^&#123; [fromView removeFromSuperview]; [containerView addSubview:toView]; &#125;</span><br><span class="line">           completion:<span class="literal">NULL</span>];</span><br><span class="line"><span class="comment">// 上面代码创建了一个翻转过渡的动画，执行过程中fromView 被移除，添加了toView，看起来像从fromView翻转到了toView；</span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">UIView</span>.transitionWithView(animationContainerView!,</span><br><span class="line">duration: <span class="number">0.33</span>,</span><br><span class="line">options: [.<span class="type">CurveEaseOut</span>, .<span class="type">TransitionFlipFromBottom</span>],</span><br><span class="line">animations: &#123;</span><br><span class="line"><span class="keyword">self</span>.animationContainerView!.addSubview(newView)</span><br><span class="line">&#125;, completion: <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// 添加</span></span><br><span class="line"></span><br><span class="line"><span class="type">UIView</span>.transitionWithView(animationContainerView!,</span><br><span class="line">duration: <span class="number">0.33</span>,</span><br><span class="line">options: [.<span class="type">CurveEaseOut</span>, .<span class="type">TransitionFlipFromBottom</span>],</span><br><span class="line">animations: &#123;</span><br><span class="line"><span class="keyword">self</span>.newView.removeFromSuperview()</span><br><span class="line">&#125;, completion: <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// 移除</span></span><br><span class="line"></span><br><span class="line"><span class="type">UIView</span>.transitionWithView(<span class="keyword">self</span>.newView, duration: <span class="number">0.33</span>, options:</span><br><span class="line">[.<span class="type">CurveEaseOut</span>, .<span class="type">TransitionFlipFromBottom</span>], animations: &#123;</span><br><span class="line"><span class="keyword">self</span>.newView.hidden = <span class="literal">true</span></span><br><span class="line">&#125;, completion: <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// 隐藏</span></span><br><span class="line"></span><br><span class="line"><span class="type">UIView</span>.transitionFromView(<span class="keyword">self</span>.oldView!, toView: <span class="keyword">self</span>.newView!,</span><br><span class="line"></span><br><span class="line">duration: <span class="number">0.33</span>, options: [.<span class="type">TransitionFlipFromTop</span>],</span><br><span class="line"></span><br><span class="line">completion: <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// 替换</span></span><br></pre></td></tr></table></figure><h2 id="Keyframe-Animations"><a href="#Keyframe-Animations" class="headerlink" title="Keyframe Animations"></a>Keyframe Animations</h2><p><img src="http://ww2.sinaimg.cn/large/a50bf7fdjw1f7hx8ds7kuj20kr04rt9c.jpg" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">planDepart</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">let</span> orginalCenter = planeImage.center</span><br><span class="line">        <span class="type">UIView</span>.animateKeyframesWithDuration(<span class="number">1.5</span>, delay: <span class="number">0.0</span>, options: [], animations: &#123;</span><br><span class="line">            <span class="comment">// add kekframes</span></span><br><span class="line">            <span class="type">UIView</span>.addKeyframeWithRelativeStartTime(<span class="number">0.0</span>, relativeDuration: <span class="number">0.25</span>, animations: &#123;</span><br><span class="line">                <span class="keyword">self</span>.planeImage.center.x += <span class="number">80.0</span></span><br><span class="line">                <span class="keyword">self</span>.planeImage.center.y += <span class="number">10</span></span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="type">UIView</span>.addKeyframeWithRelativeStartTime(<span class="number">0.0</span>, relativeDuration: <span class="number">0.4</span>, animations: &#123;</span><br><span class="line">                <span class="keyword">self</span>.planeImage.transform = <span class="type">CGAffineTransformMakeRotation</span>(<span class="type">CGFloat</span>(-<span class="type">M_PI_4</span>/<span class="number">2</span>))</span><br><span class="line">            &#125;)</span><br><span class="line">            </span><br><span class="line">            <span class="type">UIView</span>.addKeyframeWithRelativeStartTime(<span class="number">0.25</span>, relativeDuration: <span class="number">0.25</span>, animations: &#123;</span><br><span class="line">                <span class="keyword">self</span>.planeImage.center.x += <span class="number">100.0</span></span><br><span class="line">                <span class="keyword">self</span>.planeImage.center.y -= <span class="number">50.0</span></span><br><span class="line">                <span class="keyword">self</span>.planeImage.alpha = <span class="number">0.0</span></span><br><span class="line">            &#125;)</span><br><span class="line">            </span><br><span class="line">            <span class="type">UIView</span>.addKeyframeWithRelativeStartTime(<span class="number">0.51</span>, relativeDuration: <span class="number">0.01</span>, animations: &#123;</span><br><span class="line">                <span class="keyword">self</span>.planeImage.transform = <span class="type">CGAffineTransformIdentity</span></span><br><span class="line">                <span class="keyword">self</span>.planeImage.center = <span class="type">CGPoint</span>(x: <span class="number">0.0</span>, y:orginalCenter.y)</span><br><span class="line">            &#125;)</span><br><span class="line">            </span><br><span class="line">            <span class="type">UIView</span>.addKeyframeWithRelativeStartTime(<span class="number">0.55</span>, relativeDuration: <span class="number">0.45</span>, animations: &#123;</span><br><span class="line">                <span class="keyword">self</span>.planeImage.alpha = <span class="number">1.0</span></span><br><span class="line">                <span class="keyword">self</span>.planeImage.center = orginalCenter</span><br><span class="line">            &#125;)</span><br><span class="line">            &#125;, completion: <span class="literal">nil</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class func addKeyframeWithRelativeStartTime(_ frameStartTime: Double, relativeDuration frameDuration: Double, animations animations: () -&gt; Void)</span></span><br><span class="line">frameStartTime  frameDuration 取值范围都为 <span class="number">0</span>-<span class="number">1</span> 表示占总时长的百分比。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Raywenderlich的《iOS Animations by Tutorials》 读书笔记&lt;br&gt;
    
    </summary>
    
    
      <category term="Animations" scheme="https://www.devorz.com/tags/Animations/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发中的深复制与浅拷贝</title>
    <link href="https://www.devorz.com/2016/07/27/iOS%E2%80%94copy/"/>
    <id>https://www.devorz.com/2016/07/27/iOS—copy/</id>
    <published>2016-07-27T15:33:41.000Z</published>
    <updated>2018-07-13T06:24:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS开发中的深复制与浅拷贝<br><a id="more"></a></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Collections/Art/CopyingCollections_2x.png" alt="苹果官方图"></p><p>如图，左边为浅复制，右边为深复制。</p><p>浅拷贝之后的内容与原始内容指针地址相同，深拷贝之后的内容指向原始内容相关对象的一份拷贝。(深拷贝会逐个元素发送Copy消息，用拷贝得到元素创建Set);</p><p>简言之：浅拷贝为指针拷贝，深拷贝为内容拷贝。</p><h2 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰"></a>举个🌰</h2><ul><li>浅复制（Shallow Copies）</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *shallowCopyArray = [someArray copyWithZone:<span class="literal">nil</span>];</span><br><span class="line"> </span><br><span class="line"><span class="built_in">NSDictionary</span> *shallowCopyDict = [[<span class="built_in">NSDictionary</span> alloc] initWithDictionary:someDictionary copyItems:<span class="literal">NO</span>]</span><br></pre></td></tr></table></figure><ul><li>深复制 (Deep Copies)</li></ul><ol><li>单层深复制(one-level-deep copy)。</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用`initWithArray：copyItems`用YES做为第二个可以实现单层深复制(one-level-deep copy)。</span></span><br><span class="line"><span class="built_in">NSArray</span> *deepCopyArray=[[<span class="built_in">NSArray</span> alloc] initWithArray:someArray copyItems:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure><p>如果你用这种方法深复制，集合里的每个对象都会收到 copyWithZone: 消息。如果集合里的对象遵循 NSCopying 协议，那么对象<br>复制后生成新的集合。如果对象没有遵循 NSCopying 协议，而尝试用这种方法进行深复制，会在运行时出错。</p><p>然而，copyWithZone: 这种拷贝方式只能够提供一层内存拷贝(one-level-deep copy)，而非真正的深复制。</p><ol start="2"><li>真正的深复制(A true deep copy)</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归档后解档 实现真正的深复制。</span></span><br><span class="line"><span class="built_in">NSArray</span>的* trueDeepCopyArray = [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithData：</span><br><span class="line">          [的<span class="built_in">NSKeyedArchiver</span> archivedDataWithRootObject：oldArray]];</span><br></pre></td></tr></table></figure><h2 id="复制和可变性"><a href="#复制和可变性" class="headerlink" title="复制和可变性"></a>复制和可变性</h2><p>对immutable对象进行copy操作，是指针复制，mutableCopy操作时内容复制；对mutable对象进行copy和mutableCopy都是内容复制。用代码简单表示如下：</p><p>[immutableObject copy] // 浅复制<br>[immutableObject mutableCopy] //深复制<br>[mutableObject copy] //深复制<br>[mutableObject mutableCopy] //深复制</p><p>没有专门定义深拷贝的协议，所以如果需要深拷贝，需要编写一个专供深拷贝所用的方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS开发中的深复制与浅拷贝&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://www.devorz.com/tags/iOS/"/>
    
      <category term="NSCopying" scheme="https://www.devorz.com/tags/NSCopying/"/>
    
  </entry>
  
  <entry>
    <title>从NSArray看Objective-C中的类族(Class Clusters)和工厂模式</title>
    <link href="https://www.devorz.com/2016/07/16/Class-Cluster/"/>
    <id>https://www.devorz.com/2016/07/16/Class-Cluster/</id>
    <published>2016-07-16T12:58:26.000Z</published>
    <updated>2018-07-13T06:24:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果要继承自<code>NSString，NSArray，NSDictionary，NSNumber</code>，要当心！</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>工厂模式(Factory pattern)：</li></ul><blockquote><p>“Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.”</p></blockquote><p>即：定义一个接口来创建对象，让子类来决定实例哪个类。工厂方法让一个类的实例化延迟到子类中。</p><ul><li>类簇(class cluster)：</li></ul><blockquote><p>Class clusters are a design pattern that the Foundation framework makes extensive use of. Class clusters group a number of private concrete subclasses under a public abstract superclass. The grouping of classes in this way simplifies the publicly visible architecture of an object-oriented framework without reducing its functional richness. Class clusters are based on the Abstract Factory design pattern. -<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaEncyclopedia/ClassClusters/ClassClusters.html]" target="_blank" rel="noopener">《Concepts in Objective-C Programming》</a></p></blockquote><p>类簇是Foundation框架中广泛使用的设计模式。类簇将一些私有的、具体的子类组合在一个公共的、抽象的超类下面，以这种方法来组织类可以简化一个面向对象框架的公开架构，而又不减少功能的丰富性。类族是基于抽象工厂模式。<br>这样做的目的是为了接口的简单性。<br>官方文档中举了NSNumber 作为例子.<br><img src="https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaEncyclopedia/Art/cluster3.gif" alt=""><br>类族模式体现在 使用NSNumber的<code>numberWith…</code>方法时，返回类型并不总是NSNumber类型，例如</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSNumber</span> *boolNumber = [<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">true</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *intNumber = [<span class="built_in">NSNumber</span> numberWithInteger:<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"boolNumber class = %@ "</span>,[boolNumber <span class="keyword">class</span>]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"intNumber class = %@"</span>,[intNumber <span class="keyword">class</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">2016-07-16 23:27:29.834 Test[19339:874972] boolNumber class = __NSCFBoolean </span></span><br><span class="line"><span class="comment">2016-07-16 23:27:29.835 Test[19339:874972] intNumber class = __NSCFNumber</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>__NSCFBoolean</code>和<code>__NSCFNumber</code>都是NSNumber的子类，但是使用者不必关心这些子类，只需要把它当作是一个NSNumber对象就行了。这种设计模式保证了接口的简单性。<br>但是当我要创建子类时，麻烦就来了。</p><h2 id="SubClass"><a href="#SubClass" class="headerlink" title="SubClass"></a>SubClass</h2><p>以NSArray为例，<br>如果我创建一个继承自NSArray的MonthArray类</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">MonthArray *months = [[MonthArray alloc]init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,months.count);</span><br><span class="line"></span><br><span class="line"><span class="comment">//上述代码并没有和预想的一样，输出0;而是报了如下错误：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*Output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '*** -[NSArray count]: method only defined for abstract class.  Define -[MonthArray count]!'</span></span><br><span class="line"><span class="comment">*** First throw call stack:</span></span><br><span class="line"><span class="comment">(</span></span><br><span class="line"><span class="comment">0   CoreFoundation                      0x00007fff8b4124f2 __exceptionPreprocess + 178</span></span><br><span class="line"><span class="comment">1   libobjc.A.dylib                     0x00007fff93302f7e objc_exception_throw + 48</span></span><br><span class="line"><span class="comment">2   CoreFoundation                      0x00007fff8b47cccf __CFRequireConcreteImplementation + 271</span></span><br><span class="line"><span class="comment">3   CoreFoundation                      0x00007fff8b469d97 -[NSArray count] + 39</span></span><br><span class="line"><span class="comment">4   Test                                0x0000000100000e9e main + 94</span></span><br><span class="line"><span class="comment">5   libdyld.dylib                       0x00007fff89a775ad start + 1</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">libc++abi.dylib: terminating with uncaught exception of type NSException</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>method only defined for abstract class 即：<strong>抽象类仅定义了方法</strong>。</p><p>在<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaEncyclopedia/ClassClusters/ClassClusters.html" target="_blank" rel="noopener">官方文档</a>中找到了类簇的子类扩展的方法：</p><pre><code>A True SubclassA new class that you create within a class cluster must:Be a subclass of the cluster’s abstract superclassDeclare its own storageOverride all initializer methods of the superclassOverride the superclass’s primitive methods (described below)</code></pre><p>要做类族的子类，就要做到：</p><ol><li>以公共“抽象”类为父类，比如NSNumber、NSArray等，而非其子类</li><li>提供自定义存储</li><li>重写（覆盖）父类所有初始化方法</li><li>重写父类中“原始”方法</li></ol><p>原始方法(primitive methods)是一个类的接口的基础，以NSArray为例，以它的两个原始方法<code>count</code>和<code>objectAtIndex:</code>为基础，其他派生方法(derived methods)可以派生实现,例如：</p><table><thead><tr><th>Derived Method</th><th>Possible Implementation</th></tr></thead><tbody><tr><td><code>lastObject</code></td><td><code>[self objectAtIndex: ([self count] –1)]</code></td></tr><tr><td><code>containsObject:</code></td><td>递增索引反复调用<code>objectAtIndex</code>，然后对所得到的对象进行等同性判断</td></tr></tbody></table><p>到这里，《Effective-Objective-C 2.0》第9条讲到<code>从类族的公共类抽象基类中继承子类时要当心，若有开发文档，则应首先阅读</code>的原因，已经清晰明了了。<br>示例代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.h</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;foundation/foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MonthArray</span> : <span class="title">NSArray</span></span></span><br><span class="line">+ monthArray;</span><br><span class="line">- (<span class="keyword">unsigned</span>)count;</span><br><span class="line">- (<span class="keyword">id</span>)objectAtIndex:(<span class="keyword">unsigned</span>)index;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"MonthArray.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MonthArray</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> MonthArray *sharedMonthArray = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *months[] = &#123; <span class="string">@"January"</span>, <span class="string">@"February"</span>, <span class="string">@"March"</span>,</span><br><span class="line">    <span class="string">@"April"</span>, <span class="string">@"May"</span>, <span class="string">@"June"</span>, <span class="string">@"July"</span>, <span class="string">@"August"</span>, <span class="string">@"September"</span>,</span><br><span class="line">    <span class="string">@"October"</span>, <span class="string">@"November"</span>, <span class="string">@"December"</span> &#125;;</span><br><span class="line"></span><br><span class="line">+ monthArray</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!sharedMonthArray) &#123;</span><br><span class="line">        sharedMonthArray = [[MonthArray alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sharedMonthArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">unsigned</span>)count</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">id</span>)objectAtIndex:(<span class="keyword">unsigned</span> <span class="keyword">int</span>)index&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= [<span class="keyword">self</span> count])&#123;</span><br><span class="line">        [<span class="built_in">NSException</span> raise:<span class="built_in">NSRangeException</span> format:<span class="string">@"***%s: index(%d) beyond bounds (%d)"</span>, sel_getName(_cmd), index,[<span class="keyword">self</span> count] - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> months[index];   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MonthArray *months = [[MonthArray alloc]init];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"lastmonth = %@"</span>,months.lastObject);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"firstmonth = %@"</span>,months.firstObject);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">2016-07-17 00:13:05.558 Test[19513:920103] lastmonth = December</span></span><br><span class="line"><span class="comment">2016-07-17 00:13:05.559 Test[19513:920103] firstmonth = January</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="对象的所属类判断"><a href="#对象的所属类判断" class="headerlink" title="对象的所属类判断"></a>对象的所属类判断</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">MonthArray *months = [[MonthArray alloc]init]; </span><br><span class="line"><span class="built_in">BOOL</span> isEqual1 = [months <span class="keyword">class</span>] == [<span class="built_in">NSArray</span> <span class="keyword">class</span>];<span class="comment">//0</span></span><br><span class="line"><span class="built_in">BOOL</span> isEqual2 = [months isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]];<span class="comment">//1</span></span><br><span class="line"><span class="built_in">BOOL</span> isEqual3 = [months isMemberOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]];<span class="comment">//0</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">BOOL</span> isEqual4 = [months <span class="keyword">class</span>] == [MonthArray <span class="keyword">class</span>];<span class="comment">//1</span></span><br><span class="line"><span class="built_in">BOOL</span> isEqual5 = [months isKindOfClass:[MonthArray <span class="keyword">class</span>]];<span class="comment">//1</span></span><br><span class="line"><span class="built_in">BOOL</span> isEqual6 = [months isMemberOfClass:[MonthArray <span class="keyword">class</span>]];<span class="comment">//1</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,isEqual1);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,isEqual2);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,isEqual3);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,isEqual4);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,isEqual5);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,isEqual6);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">2016-07-17 00:17:01.650 Test[19556:924326] 0</span></span><br><span class="line"><span class="comment">2016-07-17 00:17:01.651 Test[19556:924326] 1</span></span><br><span class="line"><span class="comment">2016-07-17 00:17:01.651 Test[19556:924326] 0</span></span><br><span class="line"><span class="comment">2016-07-17 00:17:01.651 Test[19556:924326] 1</span></span><br><span class="line"><span class="comment">2016-07-17 00:17:01.651 Test[19556:924326] 1</span></span><br><span class="line"><span class="comment">2016-07-17 00:17:01.651 Test[19556:924326] 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>isKindOfClass</code>：是否为该类或者该类的子类实例对象；<br><code>isMemberOfClass</code> 是否为该类的实例对象。<br><code>==</code>在此处和<code>isMemberOfClass</code>效果一样。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>当然一般我们不会继承自类族类，扩充方法用Category实现，遇到需要增加实例变量时，可以考虑一下<a href="http://jatstar.cn/2016/07/14/Associative-References/" target="_blank" rel="noopener">关联引用</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果要继承自&lt;code&gt;NSString，NSArray，NSDictionary，NSNumber&lt;/code&gt;，要当心！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Effective-Objective-C 2.0" scheme="https://www.devorz.com/tags/Effective-Objective-C-2-0/"/>
    
      <category term="Class Clusters" scheme="https://www.devorz.com/tags/Class-Clusters/"/>
    
      <category term="设计模式" scheme="https://www.devorz.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Associative-References(关联引用)</title>
    <link href="https://www.devorz.com/2016/07/14/Associative-References/"/>
    <id>https://www.devorz.com/2016/07/14/Associative-References/</id>
    <published>2016-07-14T15:55:11.000Z</published>
    <updated>2018-07-13T06:24:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>Associative-References 的使用<br><a id="more"></a></p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>  有时需要在对象中存放相关信息，我们通常使用对象的所属类继承一个子类，然后改用，这个对象的子类。但并非所有对象都能这么做，比如类簇(Class Clusters)，是不建议被继承的。那么这个时候就可以利用<code>关联引用</code>(Associative-References)解决此问题。</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="comment">//设置关联</span></span><br><span class="line"><span class="keyword">void</span> objc_setAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">void</span> *key, <span class="keyword">id</span> value, objc_AssociationPolicy policy)</span><br><span class="line"><span class="comment">//获取关联对象</span></span><br><span class="line"><span class="keyword">id</span> objc_getAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">void</span> *key)</span><br><span class="line"><span class="comment">//移除关联</span></span><br><span class="line"><span class="keyword">void</span> objc_removeAssociatedObjects(<span class="keyword">id</span> object)</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td>object</td><td style="text-align:left">被关联的对象</td></tr><tr><td>key</td><td style="text-align:left">关联的key</td></tr><tr><td>value</td><td style="text-align:left">关联的key对应的对象</td></tr><tr><td>policy</td><td style="text-align:left">内存管理策略</td></tr></tbody></table><table><thead><tr><th>objc_AssociationPolicy枚举</th><th style="text-align:center">对应的@property修饰符</th></tr></thead><tbody><tr><td>OBJC_ASSOCIATION_ASSIGN</td><td style="text-align:center">assign</td></tr><tr><td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td><td style="text-align:center">nonatomic,retain</td></tr><tr><td>OBJC_ASSOCIATION_COPY_NONATOMIC</td><td style="text-align:center">nonatomic,copy</td></tr><tr><td>OBJC_ASSOCIATION_RETAIN</td><td style="text-align:center">retain</td></tr><tr><td>OBJC_ASSOCIATION_COPY</td><td style="text-align:center">copy</td></tr></tbody></table><p><strong>有别于NSDictionary,关联引用中，想让两个key匹配到同一个value，必须两个key的指针完全相等才行。所以key通常使用静态全局变量</strong></p><h2 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰"></a>举个🌰</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *EOCMyAlertViewKey = <span class="string">"EOCMyAlertViewKey"</span>;  </span><br><span class="line"> </span><br><span class="line">- (<span class="keyword">void</span>)askUserAQuestion &#123;  </span><br><span class="line">    <span class="built_in">UIAlertView</span> *alert = [[<span class="built_in">UIAlertViewalloc</span>]  </span><br><span class="line">                             initWithTitle:<span class="string">@"Question"</span>  </span><br><span class="line">                               message:<span class="string">@"What do you want to do?"</span>  </span><br><span class="line">                                  delegate:<span class="keyword">self</span>  </span><br><span class="line">                        cancelButtonTitle:<span class="string">@"Cancel"</span>  </span><br><span class="line">                        otherButtonTitles:<span class="string">@"Continue"</span>, <span class="literal">nil</span>];  </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">void</span> (^block)(<span class="built_in">NSInteger</span>) = ^(<span class="built_in">NSInteger</span> buttonIndex)&#123;  </span><br><span class="line">          <span class="keyword">if</span> (buttonIndex == <span class="number">0</span>) &#123;  </span><br><span class="line">              [<span class="keyword">self</span> doCancel];  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            [<span class="keyword">self</span> doContinue];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;;  </span><br><span class="line"> </span><br><span class="line">      objc_setAssociatedObject(alert,  </span><br><span class="line">                               EOCMyAlertViewKey,  </span><br><span class="line">                               block,  </span><br><span class="line">                               BJC_ASSOCIATION_COPY);  </span><br><span class="line"> </span><br><span class="line">      [alert show];  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="comment">// UIAlertViewDelegate protocol method  </span></span><br><span class="line">- (<span class="keyword">void</span>)alertView:(<span class="built_in">UIAlertView</span>*)alertView  </span><br><span class="line">        clickedButtonAtIndex:(<span class="built_in">NSInteger</span>)buttonIndex  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">void</span> (^block)(<span class="built_in">NSInteger</span>) =  </span><br><span class="line">        objc_getAssociatedObject(alertView, EOCMyAlertViewKey);  </span><br><span class="line">    block(buttonIndex);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Associative-References 的使用&lt;br&gt;
    
    </summary>
    
    
      <category term="runtime" scheme="https://www.devorz.com/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>《Effective-Objective-C 2.0》笔记</title>
    <link href="https://www.devorz.com/2016/07/10/Effective-Objective-C-2-0/"/>
    <id>https://www.devorz.com/2016/07/10/Effective-Objective-C-2-0/</id>
    <published>2016-07-10T14:04:52.000Z</published>
    <updated>2018-07-13T06:24:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>中文译名《编写高质量iOS与OS X代码的52个有效方法》。<br>关于这本书的一些笔记。<br><a id="more"></a></p><h2 id="熟悉Objective-C"><a href="#熟悉Objective-C" class="headerlink" title="熟悉Objective-C"></a>熟悉Objective-C</h2><ul><li><p>起源</p><ol><li>由消息型语言鼻祖<a href="http://baike.baidu.com/view/76337.htm" target="_blank" rel="noopener">Smalltalk</a>演化而来。是C语言的超集。</li><li>与函数式语言关键区别：消息结构的语言，运行时所执行的代码由运行环境决定(<a href="http://baike.baidu.com/link?url=Vh0w0LkFM5iY7JITi01r4m7wzruY5L2nxKTMUe60sT7sVj_YGdqnfI1Ja7RCowAVErzRYKKWUhu-T8GKD5fAIq" target="_blank" rel="noopener">动态绑定</a>)；函数调用的语言，由编译器决定。</li><li><code>NSString *someString</code> 中 someString为指向NSString 的指针。<code>Type *</code> 声明的对象总是被分配的<code>堆区(heap space)</code> 中，而绝不可能分配的<code>栈区(stack)</code>。</li><li>如果只需保存<code>int float double char</code> 等<code>非对象类型（nonoobject type）</code> ，使用C结构体(如<code>CGRect</code>)比使用OC对象性能更优，因为创建OC对象需要分配及释放堆区内存等额外开销。 </li></ol></li><li><p>在类的头文件中尽量少引入其他头文件</p><ol><li>头文件在类的头文件中，少引入头文件，使用@Class 向前声明即可。 然后在实现文件中再引入那些类的头文件。这样可以降低类之间的耦合。</li><li>无法使用向前声明的情况，如果 引入当前类遵守的某一项协议，此时把协议单独放下一个头文件中，再将其引入。</li></ol></li><li><p>多用字面量语法，少用与之等价的方法。</p></li></ul><ol><li>举个🌰:</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSNumber</span> *intNumber = @<span class="number">1</span>;</span><br><span class="line"><span class="built_in">NSNumber</span> *floatNumber = @<span class="number">2.5</span>f;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSArray</span> *namesArray = @[<span class="string">@"Jat"</span>,<span class="string">@"Jay"</span>,<span class="string">@"Vae"</span>];</span><br><span class="line"><span class="built_in">NSString</span> *myName = namesArray[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSDictionary</span> *personData = @&#123;<span class="string">@"ChineseName"</span>:<span class="string">@"张建宇"</span>,</span><br><span class="line"><span class="string">@"EnglishName"</span>:<span class="string">@"Jat"</span>,</span><br><span class="line"><span class="string">@"age"</span>:<span class="string">@"23"</span>&#125;</span><br><span class="line">Number *myAge = personData[<span class="string">@"age"</span>];</span><br><span class="line"><span class="comment">//通过字面量创建的数组或者字典 ，如果值中有nil，会抛出异常。</span></span><br></pre></td></tr></table></figure><ul><li><p>多用类型常量，少用＃define 预处理指令。</p><ol><li>＃define定义的出来的常量，不包含类型信息，编译器需要再编译前执行查找替换，会增加编译时间。</li><li>只在当前类使用的常量，可以使用 <code>static const</code> 在.m中定义。</li><li>在头文件中使用<code>extern</code>来声明全局变量,并在相关实现文件中定义其值。命名时，通常使用于是相关的类名最为前缀。如<code>UITextFieldTextDidBeginEditingNotification</code> 。</li><li><a href="http://jatstar.cn/2016/01/10/const-static-extern/" target="_blank" rel="noopener">《iOS开发中 const,static,extern用法总结》</a></li></ol></li><li><p>使用枚举来表示状态，选项，状态码</p><ol><li>易懂的枚举名可以提高代码的可读性。</li><li>选项为多选时，使用二进制表示枚举值，以便通过按位或将其组合起来。🌰：<code>UIInterfaceOrientationMask</code>。</li><li>switch语句中，不要实现default分支。这样加入新的枚举之后，编译器会提示：switch语句没有处理所有枚举值。</li></ol></li></ul><h2 id="消息／对象／运行时"><a href="#消息／对象／运行时" class="headerlink" title="消息／对象／运行时"></a>消息／对象／运行时</h2><ul><li><p>理解“属性” 这一概念 <a href="http://jatstar.cn/2016/01/07/Objective-C-property/" target="_blank" rel="noopener">Objective-C语法@property详解</a></p></li><li><p>在对象内部尽量直接访问实例变量。</p><ol><li>直接访问实例变量不经过方法派发，比点语法快。</li><li>⚠️直接访问copy修饰的属性，不会掉用setter方法，所以不会拷贝该属性。</li><li>⚠️不会触发KVO通知。是否会产生问题，视情况而定。</li><li>初始化方法和dealloc方法中，总是应该直接访问。</li><li>⚠️注意考虑懒加载的情况下，要使用点语法。</li></ol></li><li><p>理解“对象等同性”这一概念。</p><ol><li><code>==</code>比较的是指针地址是否一样。</li><li>特有的等同性判断方法，如<code>isEqualToString</code>比<code>isEqual</code>快一些。</li><li>相同的对象必须具有相同的哈希码，但是哈希码相同的对象未必相同。</li><li>不必逐条比较每个属性的哈希码，依情况，使用速度快，碰撞率低的算法。</li></ol></li><li><p>以“类族模式”隐藏实现细节</p><ol><li>例如<code>UIButton</code> 中的 <code>+ (instancetype)buttonWithType:(UIButtonType)buttonType</code>.</li><li>可以把实现细节隐藏在一个公共的接口后面。</li></ol></li><li><p><a href="http://jatstar.cn/2016/07/14/Associative-References/" target="_blank" rel="noopener">在既有类中使用关联对象存放自定义数据</a></p></li><li><p>理解objc_msgSend 的作用</p><ol><li><code>Objective-c</code> “动态绑定(dynamic binding)” 的特性使得所要调用的函数直到运行时才能确定。通过<code>动态消息派发系统(dynamic message dicpatch system)</code>来查出对应的方法并执行。</li><li>消息由接收者(receiver)，选择子(selecter)，以及参数构成。调用方法实际上相当于在给对象发送消息。</li></ol></li><li><p>理解消息转发机制 //TODO： 待续</p></li><li><p>用<code>方法调配技术</code>调试<code>黑盒方法</code> </p></li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Category</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"NSString+Test.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSString</span> (<span class="title">Test</span>)</span></span><br><span class="line">- (<span class="built_in">NSString</span>*)eoc_myLowercaseString &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *lowercase = [<span class="keyword">self</span> eoc_myLowercaseString];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ =&gt; %@"</span>, <span class="keyword">self</span>, lowercase);</span><br><span class="line">    <span class="keyword">return</span> lowercase;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不会死循环，因为eoc_myLowercaseString与lowercaseString方法互换了，运行时期间eoc_myLowercaseString选择子实际上对应的原有的lowercaseString方法实现。</span></span><br><span class="line">+ (<span class="keyword">void</span>)load&#123;</span><br><span class="line">    Method originalMethod = class_getInstanceMethod([<span class="built_in">NSString</span> <span class="keyword">class</span>],<span class="keyword">@selector</span>(lowercaseString));</span><br><span class="line">    Method swappedMethod = class_getInstanceMethod([<span class="built_in">NSString</span> <span class="keyword">class</span>],<span class="keyword">@selector</span>(eoc_myLowercaseString));</span><br><span class="line">    method_exchangeImplementations(originalMethod, swappedMethod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span> </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">测试一下：</span></span><br><span class="line"><span class="comment">NSString *string = @"Hello World";</span></span><br><span class="line"><span class="comment">NSString *textString = [string lowercaseString];</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">Hello World =&gt; hello world</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>理解<code>类对象</code>的用意 //TODO: 待续</li></ul><h2 id="接口与API设计"><a href="#接口与API设计" class="headerlink" title="接口与API设计"></a>接口与API设计</h2><ul><li>使用前缀避免命名空间冲突。</li><li><p>提供<code>全能初始化方法</code></p><ol><li>提供一个全能初始化方法，并与文档中指明，其他初始化方法均调用此方法。</li><li>全能初始化方法与超类不同时，应该重写，冲突时，应该加上抛异常机制提示。</li></ol></li><li><p>实现<code>description</code>方法</p><ol><li>自定义类，覆写<code>description</code>方法，返回的字符串，NSLog时的显示该字符串；</li><li>重写<code>debugDescription</code>，改变调试控制台输出信息，默认为<code>description</code>方法的返回值。</li></ol></li><li><p>尽量使用不可变对象。</p></li><li>使用清晰而且协调的命名方式</li><li>为私有方法名加前缀<ol><li>给私有方法名加上前缀(虽然我感觉没必要～也没见过知名开源项目有加；但是爱老婆说按规范要加)</li><li>不要使用下划线做私有方法的前缀，因为这种做法是预留给苹果的。</li></ol></li><li>理解Objective-C错误模型<ol><li>只有发生使整个应用崩溃的严重错误时，才之用异常。</li><li>不那么严重的错误，可以指派委托方法来处理错误，也可以把错误信息放在NSError里，由NSLog输出。 </li></ol></li><li>理解NSCoding协议。<ol><li>想令对象具有拷贝功能，需实现NSCoying协议；如果对象有可变版本，还需要实现NSMutableCopying协议。</li><li>浅拷贝之后的内容与原始内容指针地址相同，深拷贝之后的内容指向原始内容相关对象的一份拷贝。(深拷贝会逐个元素发送Copy消息，用拷贝得到元素创建Set);</li></ol></li><li>通过委托与数据源协议进行对象间的通信。<ol><li><code>@property(nonatomic,weak)id&lt;ClassNameDelegate&gt; delegate</code> 用weak修饰，，防止循环引用(retain cycle);</li></ol></li><li>将类的实现代码分散到便于管理的数个分类之中。//易于管理</li><li>总是为第三方类的分类名称增加前缀。</li><li>勿在分类中声明属性。<ol><li>封装数据所用的全部属性都定义在主接口里。</li><li>关联对象可以解决分类不能合成实例变量的问题。//本书作者认为此方法内存管理上容易出错，不是很推荐。</li></ol></li><li>使用“class-continuation”分类 隐藏实现细节 //就是Extension吧，匿名的分类。</li><li>通过协议提供匿名对象。 //隐藏返回值类型</li></ul><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><ul><li>理解引用计数</li><li>以ARC简化引用计数</li><li>在dealloc方法中只释放引用并移除监听(KVO和Notifications)</li><li>编写 “异常安全代码”时留意内存管理问题(即：使用<code>@try...@catch</code>语法时)</li><li>以弱引用避免保留环(retain cycle :循环引用)</li><li>以“自动释放池块”降低内存峰值。</li><li>用“僵尸对象”调试内存管理问题。<ol><li>系统在回收对象时，可以不将其真正回收，而是把它转化为僵尸对象。</li><li>系统会修改对象的isa指针，令其指向特殊的僵尸类。僵尸类能够响应所有的选择子，打印一条包含消息内容以及接收者的消息，然后终止程序。</li></ol></li><li>不要使用<code>retainCount</code>。(ARC模式下，此方法废弃了)。</li></ul><h2 id="block与GCD"><a href="#block与GCD" class="headerlink" title="block与GCD"></a><code>block</code>与<code>GCD</code></h2><p>//翻译成 块与大中枢派发也是醉了。。。</p><ul><li>理解<code>block</code>这一概念。<ol><li>语法结构： <code>return_type (^block_name)(parameters)</code></li><li>默认情况下block外的变量需要在block中修改的，需要在声明时加<code>__block</code>修饰，但block修改其所在的类的成员变量时不需要加。</li><li>定义block时，它是分配在栈区的，所以。只在其作用域范围有效。调用<code>copy</code>拷贝到堆区之后可以和OC对象一样具备引用计数。由ARC去管理。</li></ol></li><li>为常见的block类型创建typedef</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>(^SomeBlock)(<span class="built_in">BOOL</span> flag,<span class="keyword">int</span> value);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用：</span></span><br><span class="line">SomeBlock block = ^ (<span class="built_in">BOOL</span> flag,<span class="keyword">int</span> value)&#123;</span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line"><span class="keyword">return</span> value * <span class="number">5</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> value *<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用handler block降低代码的分散程度。//如AFN中的网络请求回调</li><li>用block引用其所属对象时不要出现循环引用。</li><li>多用派发队列，少用同步锁。<ol><li>派发队列可以用来表述同步语义(<code>synchornization semantic</code>),比使用<code>@synchronized</code>块和NSLock对象更简单。</li><li>使用同步和异步派发结合起来，可以实现与普通加锁一样的同步行为，而且不会阻塞执行异步派发的线程。</li><li>使用同步队列和栅栏块，可以让同步锁更加高效。</li></ol></li><li>多用GCD,少用｀performSelector｀系列方法。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SEL selector;</span><br><span class="line"><span class="keyword">if</span>(<span class="comment">/* some condition */</span>)&#123;</span><br><span class="line">selector = <span class="keyword">@selector</span>(foo);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="comment">/* some other condition */</span>)&#123;</span><br><span class="line">selector = <span class="keyword">@selector</span>(bar);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">selector = @selecter(baz)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行时才能确定调用列哪个方法，</span></span><br><span class="line"><span class="comment">编译器没有办法在编译时按ARC的内存管理原则判定返回值是不是该释放，</span></span><br><span class="line"><span class="comment">编译器没有添加释放操作。</span></span><br><span class="line"><span class="comment">这将又可能导致内存泄漏</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><p>掌握GCD和<code>NSOperationQueue</code>的使用时机。</p><ol><li>运行任务之前，可以用在NSOperation对象上调用cancel取消该任务。</li><li>可以指定任务间的依赖关系。</li><li>可以通过KVO监听NSOperation的属性。例如<code>isFinished</code>,<code>isCancelled</code>。</li><li>指定操作的优先级。</li><li>重用NSOperation对象。</li></ol></li><li><p>通过Dispathtch Group机制，根据系统资源状况来执行任务。</p></li><li>使用<code>dispatch_once</code>来执行只需运行一次的线程安全代码。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+(<span class="keyword">id</span>)sharedInstance&#123;</span><br><span class="line"><span class="keyword">static</span> SomeClass *sharedInstance = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(@onceToken,^&#123;</span><br><span class="line">sharedInstance = [[<span class="keyword">self</span> alloc]init];</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> sharedInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不要使用<code>dispatch_get_current_queue(void);</code>//调试还是可以用下的</li></ul><h2 id="系统框架"><a href="#系统框架" class="headerlink" title="系统框架"></a>系统框架</h2><ul><li><p>熟悉系统框架。</p><ol><li>CFNetWork:提供C语言级别的网络通信能力，将<code>BSDsocket</code>抽象成易于使用的接口。</li><li>CoreAudio:提供的C语言API可用来操作设备上的音频硬件。</li><li>AVFoundation:处理音频视频的录制，回放。</li><li>CoreData:用于实现数据持久化。</li><li>CoreText:提供C语言接口，用于执行文字排版以及渲染操作。</li></ol></li><li><p>多用block枚举，少用for循环。//block枚举本身通过GCD并发执行遍历，更高效。</p></li><li>对自定义其内存管理语义的cellection使用无缝桥接。</li><li>构建缓存时选用NSCache而非NSDictionary.// low memory时 NSCache会自动删减缓存</li><li>精简<code>initalize</code>和<code>load</code>的实现代码。<ol><li>iOS平台上，当类或者分类载入系统时，会先调用<code>+(void) load</code>;同时实现时，先调类里面的，再调用分类里面的。</li><li>无法判断各个类载入的顺序，所以在load方法使用第三方类比较危险。</li><li><code>load</code>方法会阻塞线程，所以要尽量精简里面的代码。</li><li>首次使用某个类是，会调用该类的<code>+(void) initalize</code>方法，可以覆写该方法做一些与类相关的初始化操作。但是同<code>load</code>一样，也应该尽量精简。</li></ol></li><li>别忘了NSTimer会保留目标对象。//weakSelf大法打破循环就好了。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;中文译名《编写高质量iOS与OS X代码的52个有效方法》。&lt;br&gt;关于这本书的一些笔记。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS开发之如何跳到系统设置里的各种设置界面</title>
    <link href="https://www.devorz.com/2016/02/04/PresentSystemViewController/"/>
    <id>https://www.devorz.com/2016/02/04/PresentSystemViewController/</id>
    <published>2016-02-04T06:57:30.000Z</published>
    <updated>2018-07-13T06:24:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前以为，苹果不支持直接从应用跳到系统设置里的WiFi界面。后来发现，这个小功能是可以实现的，而且实现起来并不麻烦。让我们一起来看看吧！</p><a id="more"></a><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>从应用跳到系统设置里的WiFi界面有这个需求存在吗？答案是肯定的。比如以下两个例子：</p><p>在没有网的状态下，你可能想提醒用户去设置界面连接WiFi。如果不能跳到WiFi界面，只能在APP里面做出文字提示。这样很多小白用户可能不会看提示，只会觉得APP没有做好。</p><p>还有一种情况，做智能家居的APP，智能硬件设备自带WiFi（局域网）。如果用户没有连接设备的WiFi进入APP时，需要提示用户去设置界面连接WiFi。</p><p>以上这两种情况只是举个例子，这个小功能的用处还是很多的，大家可以自行探索。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>info里面设置</li></ul><p>在项目中的info.plist中添加 URL types 并设置一项URL Schemes为prefs，如下图：</p><p><img src="http://ww3.sinaimg.cn/large/a50bf7fdgw1f0nbnbveoij20dv033t93.jpg" alt="image"></p><ul><li>实现代码</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"prefs:root=WIFI"</span>];</span><br><span class="line"><span class="keyword">if</span> ([[<span class="built_in">UIApplication</span> sharedApplication] canOpenURL:url])</span><br><span class="line">&#123;</span><br><span class="line">    [[<span class="built_in">UIApplication</span> sharedApplication] openURL:url];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>其他页面相关页面的配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">About — prefs:root=General&amp;path=About</span><br><span class="line">Accessibility — prefs:root=General&amp;path=ACCESSIBILITY</span><br><span class="line">Airplane Mode On — prefs:root=AIRPLANE_MODE</span><br><span class="line">Auto-Lock — prefs:root=General&amp;path=AUTOLOCK</span><br><span class="line">Brightness — prefs:root=Brightness</span><br><span class="line">Bluetooth — prefs:root=General&amp;path=Bluetooth</span><br><span class="line">Date &amp; Time — prefs:root=General&amp;path=DATE_AND_TIME</span><br><span class="line">FaceTime — prefs:root=FACETIME</span><br><span class="line">General — prefs:root=General</span><br><span class="line">Keyboard — prefs:root=General&amp;path=Keyboard</span><br><span class="line">iCloud — prefs:root=CASTLE</span><br><span class="line">iCloud Storage &amp; Backup — prefs:root=CASTLE&amp;path=STORAGE_AND_BACKUP</span><br><span class="line">International — prefs:root=General&amp;path=INTERNATIONAL</span><br><span class="line">Location Services — prefs:root=LOCATION_SERVICES</span><br><span class="line">Music — prefs:root=MUSIC</span><br><span class="line">Music Equalizer — prefs:root=MUSIC&amp;path=EQ</span><br><span class="line">Music Volume Limit — prefs:root=MUSIC&amp;path=VolumeLimit</span><br><span class="line">Network — prefs:root=General&amp;path=Network</span><br><span class="line">Nike + iPod — prefs:root=NIKE_PLUS_IPOD</span><br><span class="line">Notes — prefs:root=NOTES</span><br><span class="line">Notification — prefs:root=NOTIFICATIONS_ID</span><br><span class="line">Phone — prefs:root=Phone</span><br><span class="line">Photos — prefs:root=Photos</span><br><span class="line">Profile — prefs:root=General&amp;path=ManagedConfigurationList</span><br><span class="line">Reset — prefs:root=General&amp;path=Reset</span><br><span class="line">Safari — prefs:root=Safari</span><br><span class="line">Siri — prefs:root=General&amp;path=Assistant</span><br><span class="line">Sounds — prefs:root=Sounds</span><br><span class="line">Software Update — prefs:root=General&amp;path=SOFTWARE_UPDATE_LINK</span><br><span class="line">Store — prefs:root=STORE</span><br><span class="line">Twitter — prefs:root=TWITTER</span><br><span class="line">Usage — prefs:root=General&amp;path=USAGE</span><br><span class="line">VPN — prefs:root=General&amp;path=Network/VPN</span><br><span class="line">Wallpaper — prefs:root=Wallpaper</span><br><span class="line">Wi-Fi — prefs:root=WIFI</span><br></pre></td></tr></table></figure><p>原文 <a href="http://mp.weixin.qq.com/s?__biz=MjM5OTM0MzIwMQ==&amp;mid=401517056&amp;idx=5&amp;sn=ad89f960098b485035006eef656efe16&amp;scene=0#wechat_redirect" target="_blank" rel="noopener">iOS开发之如何跳到系统设置里的各种设置界面</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前以为，苹果不支持直接从应用跳到系统设置里的WiFi界面。后来发现，这个小功能是可以实现的，而且实现起来并不麻烦。让我们一起来看看吧！&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://www.devorz.com/tags/iOS/"/>
    
      <category term="转载" scheme="https://www.devorz.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>在iOS开发中常见的SQLite语句</title>
    <link href="https://www.devorz.com/2016/01/10/iOS-SQLite/"/>
    <id>https://www.devorz.com/2016/01/10/iOS-SQLite/</id>
    <published>2016-01-10T12:32:10.000Z</published>
    <updated>2018-07-13T06:24:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>如题,记录一些iOS开发中常见的SQLite语句.以备查阅.<br><a id="more"></a></p><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">"T_Person"</span> (</span><br><span class="line">      <span class="string">"id"</span> <span class="built_in">INTEGER</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span> AUTOINCREMENT,</span><br><span class="line">      <span class="string">"name"</span> <span class="built_in">TEXT</span>,</span><br><span class="line">      <span class="string">"age"</span> <span class="built_in">INTEGER</span>,</span><br><span class="line">      <span class="string">"heigth"</span> <span class="built_in">REAL</span></span><br><span class="line">)</span><br><span class="line">//下边是sqllite编译器里边的语句</span><br><span class="line"></span><br><span class="line"><span class="comment">/*简单约束*/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> t_student</span><br><span class="line">(</span><br><span class="line">      <span class="keyword">id</span> <span class="built_in">INTEGER</span> PRIMARY <span class="keyword">KEY</span> AUTOINCREMENT,</span><br><span class="line">      <span class="keyword">name</span> <span class="built_in">TEXT</span>,</span><br><span class="line">      age <span class="built_in">INTEGER</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> t_student</span><br><span class="line">(</span><br><span class="line">     <span class="keyword">id</span> <span class="built_in">INTEGER</span> PRIMARY <span class="keyword">KEY</span> AUTOINCREMENT,</span><br><span class="line">     <span class="keyword">name</span> <span class="built_in">TEXT</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">     age <span class="built_in">INTEGER</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*添加主键*/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> t_student</span><br><span class="line">(</span><br><span class="line">     <span class="keyword">id</span> <span class="built_in">INTEGER</span> PRIMARY <span class="keyword">KEY</span> AUTOINCREMENT,</span><br><span class="line">     <span class="keyword">name</span> <span class="built_in">TEXT</span>,</span><br><span class="line">     age <span class="built_in">INTEGER</span>,</span><br><span class="line">     score <span class="built_in">REAL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*添加主键*/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> t_student</span><br><span class="line">(</span><br><span class="line">     <span class="keyword">id</span> <span class="built_in">INTEGER</span>,</span><br><span class="line">     <span class="keyword">name</span> <span class="built_in">TEXT</span>,</span><br><span class="line">     age <span class="built_in">INTEGER</span>,</span><br><span class="line">     score <span class="built_in">REAL</span>,</span><br><span class="line">     PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*分页*/</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_student</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">id</span> <span class="keyword">ASC</span> <span class="keyword">LIMIT</span> <span class="number">30</span>, <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*排序*/</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_student</span><br><span class="line"><span class="keyword">WHERE</span> score &gt; <span class="number">50</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_student</span><br><span class="line"><span class="keyword">WHERE</span> score &lt; <span class="number">50</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">ASC</span> , score <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*计量*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> t_student</span><br><span class="line"><span class="keyword">WHERE</span> age &gt; <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*别名*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">as</span> myName, age <span class="keyword">as</span> myAge, score <span class="keyword">as</span> myScore</span><br><span class="line"><span class="keyword">FROM</span> t_student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> myName, age myAge, score myScore</span><br><span class="line"><span class="keyword">FROM</span> t_student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> s.name myName, s.age myAge, s.score myScore</span><br><span class="line"><span class="keyword">FROM</span> t_student s</span><br><span class="line"><span class="keyword">WHERE</span> s.age &gt; <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*查询*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, age, score <span class="keyword">FROM</span> t_student;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_student;</span><br></pre></td></tr></table></figure><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> t_student</span><br><span class="line"> <span class="keyword">SET</span> <span class="keyword">name</span> = <span class="string">'MM'</span></span><br><span class="line"> <span class="keyword">WHERE</span> age = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">UPDATE</span> t_student</span><br><span class="line"> <span class="keyword">SET</span> <span class="keyword">name</span> = <span class="string">'WW'</span></span><br><span class="line"> <span class="keyword">WHERE</span> age <span class="keyword">is</span> <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">UPDATE</span> t_student</span><br><span class="line"> <span class="keyword">SET</span> <span class="keyword">name</span> = <span class="string">'XXOO'</span></span><br><span class="line"> <span class="keyword">WHERE</span> age &lt; <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">UPDATE</span> t_student</span><br><span class="line"> <span class="keyword">SET</span> <span class="keyword">name</span> = <span class="string">'NNMM'</span></span><br><span class="line"> <span class="keyword">WHERE</span> age &lt; <span class="number">50</span> <span class="keyword">and</span> score &gt; <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*更新记录的name*/</span></span><br><span class="line"> <span class="keyword">UPDATE</span> t_student <span class="keyword">SET</span> <span class="keyword">name</span> = <span class="string">'zhangsan'</span>;</span><br></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_student</span><br><span class="line">(age, score, <span class="keyword">name</span>)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">'28'</span>, <span class="number">100</span>, <span class="string">'zhangsan'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_student</span><br><span class="line">(<span class="keyword">name</span>, age)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">'lisi'</span>, <span class="string">'28'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_student</span><br><span class="line">(score)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><h2 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h2> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*删除表*/</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> t_student;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如题,记录一些iOS开发中常见的SQLite语句.以备查阅.&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://www.devorz.com/tags/iOS/"/>
    
      <category term="数据持久化" scheme="https://www.devorz.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
      <category term="数据库" scheme="https://www.devorz.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="SQLite" scheme="https://www.devorz.com/tags/SQLite/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发中 const,static,extern用法总结</title>
    <link href="https://www.devorz.com/2016/01/10/const-static-extern/"/>
    <id>https://www.devorz.com/2016/01/10/const-static-extern/</id>
    <published>2016-01-09T16:14:09.000Z</published>
    <updated>2018-07-13T06:24:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS开发中怎么使用const,static,extern3个关键字.</p><a id="more"></a><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><ul><li><p>const的作用: const 是一个左结合的类型修饰符，它与其左侧的类型修饰符一起为一个类型修饰符,表示该类型只读.</p><ul><li>修饰基本变量 </li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这两种写法是一样的，const只修饰右边的基本变量b</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">20</span>; <span class="comment">// b:只读变量</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> b = <span class="number">20</span>; <span class="comment">// b:只读变量</span></span><br></pre></td></tr></table></figure><ul><li>修饰指针变量</li></ul></li></ul> <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两种方式一样</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> *p1; <span class="comment">// *p1：只读 p1:只读</span></span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">const</span> *p1; <span class="comment">// *p1：只读 p1:只读</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// const修饰指针变量p1</span></span><br><span class="line">  <span class="keyword">int</span> * <span class="keyword">const</span> p1; <span class="comment">// *p1:变量 p1:常量</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 第一个const修饰*p1 第二个const修饰 p1</span></span><br><span class="line">  <span class="comment">// 两种方式一样</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p1; <span class="comment">// *p1：常量 p1：常量</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">const</span> * <span class="keyword">const</span> p1;  <span class="comment">// *p1：常量 p1：常量</span></span><br></pre></td></tr></table></figure><pre><code>简言之:沿着*号划一条线，如果const位于*的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；如果const位于*的右侧，const就是修饰指针本身，即指针本身是常量。</code></pre><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><ul><li><p>static的作用:</p><ul><li>修饰局部变量：</li></ul><ol><li>延长局部变量的生命周期。</li><li>局部变量只会生成一份内存,<strong>只会初始化一次</strong>。 </li></ol><ul><li>修饰全局变量: </li></ul><ol><li><strong>使其只能在本文件中访问</strong>。</li></ol></li></ul><h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><ul><li>extern的作用: 声明和捕捉外部全局变量。</li></ul><h2 id="联合使用"><a href="#联合使用" class="headerlink" title="联合使用"></a><strong>联合使用</strong></h2><ul><li><p><code>static</code>与<code>const</code>:声明一个静态的全局只读变量,(仅当前文件可访问且只读).</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>  <span class="built_in">NSString</span> * <span class="keyword">const</span> key = <span class="string">@"name"</span>;</span><br></pre></td></tr></table></figure><ul><li><code>extern</code>与<code>const</code>组合:定义全局只读变量，多个文件共享。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.h文件</span><br><span class="line"><span class="keyword">extern</span>  <span class="built_in">NSString</span> * <span class="keyword">const</span> king;</span><br><span class="line">.m文件</span><br><span class="line"><span class="built_in">NSString</span>  * <span class="keyword">const</span> king = <span class="string">@"king"</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS开发中怎么使用const,static,extern3个关键字.&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://www.devorz.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://www.devorz.com/tags/Objective-C/"/>
    
      <category term="语法" scheme="https://www.devorz.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C语法@property详解</title>
    <link href="https://www.devorz.com/2016/01/07/Objective-C-property/"/>
    <id>https://www.devorz.com/2016/01/07/Objective-C-property/</id>
    <published>2016-01-07T14:58:05.000Z</published>
    <updated>2018-07-13T06:24:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>@Property是声明属性的语法，它可以快速方便的为实例变量创建存取器，并允许我们通过点语法使用存取器。</p><p>存取器（accessor）：指用于获取和设置实例变量的方法。用于获取实例变量值的存取器是getter，用于设置实例变量值的存取器是setter。<br><a id="more"></a></p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p><code>nonatomic</code> 非原子属性</p><p><code>atomic</code> 原子属性–默认属性</p><p>原子属性就是针对多线程设计的。 原子属性实现 单(线程)写 多(线程)读<br> “atomic(原子属性)在set方法内部加了一把自旋锁”<br> “nonatomic（非原子属性）下，set和get方法都不会加锁”</p><blockquote><p>原子属性内部使用的 自旋锁</p><p>自旋锁和互斥锁</p><p>共同点: 都可以锁定一段代码。 同一时间， 只有线程能够执行这段锁定的代码</p><p>区别：<br>互斥锁，在锁定的时候，其他线程会睡眠，等待条件满足，再唤醒<br>自旋锁，在锁定的时候， 其他的线程会做死循环，一直等待这条件满足，一旦条件满足，立马去执行，少了一个唤醒过程</p></blockquote><p><strong>一般iOS程序中，所有属性都声明为<code>nonatomic</code></strong></p><p>这样做的原因是：<br>在iOS中使用同步锁的开销比较大， 这会带来性能问题。一般情况下并不要求属性必须是“原子的”，因为这并不能保证“线程安全”(thread safety)，若要实现“线程安全”的操作，还需采用更为深层的锁定机制才醒。<br>例如：一个线程在连续多次读取某个属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为atomic，也还是会读取到不同的属性值。</p><p>因此，iOS程序一般都会使用<code>nonatomic</code>属性,但是在Mac OS X程序时， 使用atomic属性通常都不会有性能瓶颈</p><h2 id="读-写权限"><a href="#读-写权限" class="headerlink" title="读/写权限"></a>读/写权限</h2><ul><li><code>readwrite</code>(读写) 编译器会自动生成<code>getter</code>和<code>setter</code>方法.</li><li><code>readonly</code>(只读) 编译器会自动生成<code>getter</code>方法.</li><li>如果既覆盖了存方法，也覆盖了取方法（或者只读属性覆盖了取方法），那么编译器不会创建相应的实例变量，如果需要，必须手动声明。</li></ul><h2 id="内存管理语义"><a href="#内存管理语义" class="headerlink" title="内存管理语义"></a>内存管理语义</h2><p>以下修饰符只影响属性的<code>setter</code>方法</p><ul><li><strong><code>assgin</code></strong> 简单的赋值操作, 用来修饰(NSInteger，CGFloat）和C数据类型（int, float, double, char, 等等）。</li><li><strong><code>strong</code></strong> 保留新值,释放旧值,然后再将新值设置上去. 常用来修饰OC对象.</li><li><strong><code>weak</code></strong> 与assign类似,用来修饰oc对象表示一种弱引用关系,属性所指的的对象销毁时,属性值会被清空.</li><li><strong><code>unsafe_unretained</code></strong> 表弱引用,但是目标对象遭到摧毁时,属性值不会自动清空,unsafe的,易出现野指针.</li><li><strong><code>copy</code></strong> 设置方法不保留新值,而是将其拷贝(<code>copy</code>), 保留拷贝的对象.常用来修饰含有可深拷贝的mutable子类的类，如NSArray，NSSet，NSDictionary，NSData的，NSCharacterSet，NSIndexSet，NSString.</li></ul><p><em><code>strong</code>为指针拷贝,<code>copy</code>为内容拷贝.</em></p><h2 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h2><ul><li><strong><code>getter=&lt;name&gt;</code></strong> 用来指定<code>getter</code>方法的方法名,常见用法:</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>,<span class="keyword">nonatomic</span>,<span class="keyword">getter</span>=isOn) <span class="built_in">BOOL</span> on;</span><br></pre></td></tr></table></figure><ul><li><strong><code>setter=&lt;name&gt;</code></strong> 同理用来指定<code>setter</code>方法的方法名,不太常见.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@Property是声明属性的语法，它可以快速方便的为实例变量创建存取器，并允许我们通过点语法使用存取器。&lt;/p&gt;
&lt;p&gt;存取器（accessor）：指用于获取和设置实例变量的方法。用于获取实例变量值的存取器是getter，用于设置实例变量值的存取器是setter。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://www.devorz.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://www.devorz.com/tags/Objective-C/"/>
    
      <category term="语法" scheme="https://www.devorz.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
</feed>
